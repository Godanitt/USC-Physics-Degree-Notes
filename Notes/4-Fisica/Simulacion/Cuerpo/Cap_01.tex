\chapter{Introducción a Fortran}

En este capítulo vamos a introducir al lector el lenguaje de fortran, la prinicpal sintaxis y algunos ejemplos siempre que lo veamos adecuado. Lógicamente la mejor manera de aprender fortran es picando código, por lo que más que un manual para aprender este capítulo debería ser usado como manual de referencia en el caso de no conocer la sintaxis. Esta introdución está es un calco del Curso de Fortran impartido por Ángel Felipe Ortega del la UCM. Lógicamente hemos reducido este curso en algunos aspectos, y lo hemos ampliado en otro, a fin de que se adecue más al nivel requerido por esta asignatura.

\section{Primer contacto con fortran}


\section{Estructura del programa. Codigo fuente.}

\subsection{Formato código fuente}

El formato de condigo guente puede ser libre o fijo, y no deben mezclarse ambos en un fichero de código. El código fijo se considera obsoleto en Fortran95. En cualquier caso existen ciertas normas básicas y típicas de fortran, ataño obligatorias, que todavía se mantienen, por lo que es importante mencionarlas. Estas son:

\begin{itemize}
	\item Las sentencias de un programa se escribem en diferentes líneas.
	\item La posición de los caracterres dentro de las líneas es significativa.
	\item Columnas:
	      \begin{itemize}
		      \item 1-5. Número de etiqueta (de 1 a 5 dígitos, se usan números usualmente).
		      \item 6. Carácter de continuación de línea.
		      \item Resto. Sentencia.
	      \end{itemize}
	\item Comentarios:
	      \begin{itemize}
		      \item Las líneas en blanco se ignoran. Hacen más legible el programa.
		      \item Si el primer carácter de una línea es *, c o C la línea es de comentario.
		      \item Si aparece el carácter ! en una línea (salvo en la columna 6) lo que sigue es un comentario.
	      \end{itemize}
	\item Una línea puede contener varias sentencias separadas por punto y coma (;), el cual no puede estar en la columna 6. Sólo la primera de estas sentencias podría llevar etiqueta.
	\item Los espacios en blanco son significativos: {\tt IMPLICIT NONE, DO WHILE} (obsoleto), {\tt CASE DEFAULT}. Son opcionales en:
	      \begin{itemize}
		      \item Palabras clave dobles qeu comienzan por {\tt END} o {\tt ELSE}.
		      \item {\tt DOUBLE PRECISION, GO TO, IN OUT, SELECT CASE.}
	      \end{itemize}
	\item  El indicador de continuación de una línea es el carácter \&.
\end{itemize}

\subsection{Tipos intrínsecos de datos}

Fortran tiene los siguientes tipos de datos:

\begin{itemize}
	\item Enteros ({\tt INTEGER})
	\item Reales ({\tt REAL, DOUBLE PRECISION})
	\item Complejos ({\tt COMPLEX})
	\item Lógicos ({\tt LOGICAL})
	\item Caracteres ({\tt CHARACTER, CHARACTER(LEN=n), CHARACTER*n})
\end{itemize}

\subsubsection{Parámetros. Variables. Declaración. Asignación.}

\begin{itemize}
	\item Un parámetro tiene un valor que no se puede cambiar (PARAMETER).
	\item Una variable puede cambiar su valor cuantas veces sea necesario.
	\item Por defecto, todas las variables que empiecen por \texttt{i,j,k,l,m} o \texttt{n} son entreas y las demas reales. Es muy recomendable declarar las variables que se utilicen (la sentencia {\tt IMPLICIT NONE} obliga a declarar todas las variables).
\end{itemize}

\begin{lstlisting}[language=Fortran]
	INTEGER:: a, x, n
	DOUBLE PRECISION doble
	COMPLEX:: c, d
	CHARACTER(LEN=10) nombre, vocales*5, comput
	LOGICAL:: logico, zz
	PARAMETER (n=5, r=89.34, pi=3.141592, lac=-40, zz=.FALSE., &
		c=(2.45e2,-1.17), comput='ordenador', vocales='aeiou')

	! daria error poner n=8 porque no se puede cambiar un parametro

	x = 215
	doble = 6345.700234512846d-125
	logico = .TRUE.
	d = (2,4.5)
	a = 1200
	x = -1  				! se puede cambiar el valor de una variable
	nombre = 'Tarzan' 		! atencion al acento en algunos compiladores
	PRINT*, pi, x, doble, logico, d, a
	PRINT*, nombre, vocales
	END
\end{lstlisting}

\subsubsection{Arrays, subíndices, substrings}

\begin{itemize}
	\item Un array se define mediante su nombre y dimensiones (cantidad y límites).
	\item Por defecto el primer índice es 1. En otro caso hay que indicar el rango {\tt i1:i2}.
	\item Los elementos del array se acceden por sus índices entre paréntesis.
\end{itemize}

\begin{lstlisting}[language=Fortran]
	INTEGER n(10), n1(3,5), c(4,4,4,4), hh(0:4), bb(-6:4,2:5,75:99)
	REAL r1(5), r2(-2:4,6)
	CHARACTER(LEN=15):: mes(12), dia(0:6)

	n(3) = 4563
	n1(2,4) = n1(1,3) + 89
	hh(0) = -1
	bb(-3,4,80) = bb(-5,2,90) + 2.3*c(3,3,3,1)
	r2(-1,6) = r1(3) + r2(-2,3)
	mes(2) = 'FEBRERO'
	dia(0) = 'DOMINGO'
	PRINT*, n(3), n1(2,4), hh(0), mes(2)
	END
\end{lstlisting}



\subsection{Operadores y expresiones}

\subsubsection{Aritméticas}

\begin{itemize}
	\item Los operadores aritméticos son {\tt +, -, *, /, **}.
	\item El orden de prioridades es el mismo que en el álgebra.
	\item No puede ver operadores seguidos (incorrecto {\tt a*-b}, correcto {\tt a*(-b)}).
\end{itemize}

\subsubsection{Relacion y expresiones lógicas}

\begin{itemize}
	\item Los operadores de expresiones son:
	      \begin{table}[h!] \centering
		      \begin{tabular}{|c|c|c|c|c|c|}
			      \hline
			      {\tt .EQ.} & {\tt .NE.} & {\tt .LT.} & {\tt .LE.} & {\tt .GT.} & {\tt .GE.} \\ \hline
			      $==$       & $/=$       & $<$        & $<=$       & $>$        & $>=$       \\    \hline
		      \end{tabular}
	      \end{table}

	\item Se pueden relacionar expresiones aritméticas con expresiones lógicas y expresiones de caracteres.
	\item Es recomendable utilizar paréntesis y/ó sustituir las expresiones complicadas por combinaciones de expresiones más simples.
	\item Los operadores lógicos son:
	      \begin{table}[h!] \centering
		      \begin{tabular}{|c|c|c|c|c|c|}
			      \hline  Operador & {\tt .NOT.} & {\tt .AND.} & {\tt .OR.} & {\tt .EQV.} & {\tt .NEQV.} \\ \hline Prioridad
			                       & 1           & 2           & 3          & 4           & 4            \\    \hline
		      \end{tabular}
	      \end{table}
\end{itemize}

\subsection{Entrada y salida estándar sin formato}


Los dispositivos estándar (por defecto) de entrada y salida de datos son el teclado y la pantalla:

\begin{itemize}
	\item Lectura de datos de teclado. Son equivalentes las siguientes sentencias:
	      \begin{itemize}
		      \item {\tt READ (*,*), listavar}
		      \item {\tt READ* , listavar}
	      \end{itemize}

	\item Escritura de datos en pantalla. Son equivalentes las siguientes sentencias:
	      \begin{itemize}
		      \item {\tt WRITE (*,*), listavar}
		      \item {\tt PRINT* , listavar}
	      \end{itemize}
\end{itemize}
Donde {\tt listavar} es una lista de variables o elementos de arrays separados por comas.

\subsection{Sentencias, {\tt PROGRAM, END}}

\begin{itemize}
	\item Un programa puede comenzar con la sentencia {\tt PROGRAM nombprog.}
	\item Un programa debe terminar con la sentencia {\tt END  [PROGRAM [nombreprog]]}.
\end{itemize}
Donde \texttt{ nombreprog} es el nombre del programa, que debe empezar por una letra y admite hasta 31 letras, dígitos y guiones underscore.

\section{Setencias de control}

Las sentencias de control sirven para alterar la ejecución de las sentencias de un programa.



\subsection{Setencia {\tt CONTINUE}}

La sentencia \texttt{CONTINUE} es ejecutable, pero no realiza acción alguna. Es útil para rupturas de secuencia y manejo de errores en lectura de datos. Su número de etiqueta puede ser referenciado en sentencia \texttt{DO}.

\subsection{Setencia {\tt STOP}}

La sentencia {\tt STOP} detiene la ejecución del programa. Tiene dos variantes {\tt STOP [`mensaje'], STOP[n]}. Si está presente el literal {\tt `mensaje'} ó el número {\tt  n} (que ha de tener de 1 a 5 dígitos), se visualizan en pantalla. Puede llevar etiqueta y formar parte de una sentencia {\tt IF}, y sirve principalmente para detener la ejecución a causa de un error y con el literal `{\tt mensaje}' ó el número {\tt n}.

\subsection{Setencia {\tt GOTO}}

La sintaxis {\tt GOTO e} transfiere el control a la secuencia ejecutable con etiqueta {\tt e} que se encuentra en la misma unidad de programa que la setencia {\tt GOTO}. No se puede entrar en bloques {\tt DO, IF, CASE} desde fuera de ellos con las sentencias {\tt GOTO}. \\

Es una sentencia cuyo uso genera mucha polémica. Un programa con gran cantidad de {\tt GOTO} es difíciol de comprender, sobre todo si hay muchas transferencias a sentencias anteriores. Con una adecuada programación pueden sustituirse, con facilidad, la mayoría de las sentencias {\tt GOTO} por otras estructuras de control. Sin embargo, hay ocasiones cuya sustitución complica enormemente la lógica del programa. Es especialmente útil para tratar condiciones de error o de terminación de un bloque. Conviene NO abusar de esta sentencia. \\

Si la sentencia siguiente a la sentencia {\tt GOTO} no lleva etiqueta no se ejecutará nunca (código muerto). Es un síntoma de error de programación.

\subsection{Setencia {\tt IF}}

La sintaxis es {\tt IF (expres) sentec}. La expresión {\tt expres} debe ser escalar lógica, si es verdadera se ejecuta {\tt sentenc}; si es falsa no se ejecuta {\tt sentenc} y se continua a la sentencia siguiente. La sentencia {\tt sentenc} debe ser ejecutable, no puede ser la sentencia {\tt END} ni la sentencia inicial o final de bloques {\tt DO, IF, SELECT, CASE}. \\

Esta sentencia se suele utilizar para realizar, en función de la condición, una única asignación, una sencilla escritura de datos, una parada del programa, una ramificación del flujo del programa.

\subsection{Bloque {\tt IF-THEN-ENDIF}}

La sitáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] IF (expres) THEN 
		bloq....
	ENDIF[nomb]
\end{lstlisting}

La expresión \texttt{expres} debe ser escalar lógica. Si es verdadera se ejectutan las sentencias del bloque \texttt{bloq} entre \texttt{THEN} y \texttt{ENDIF}. Si es falsa se continúa en la siguiente sentencia a \texttt{ENDIF}. Si lleva nombre (opcional), debe ser un nombre válido en Fortran distinto de otras nombres en la unidad de alcance en la que está el bloque \texttt{IF}.


\subsection{Bloque {\tt IF-THEN-ELSE-ENDIF}}
La sitáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] IF (expres) THEN 
		bloq1 
	ELSE [nomb] 
		bloq2 
	EDNDIF[nomb] 
\end{lstlisting}

La expresión \texttt{expres} debe ser escalar lógica. Si es verdadera se ejectutan las sentencias del bloque \texttt{bloq} entre \texttt{THEN} y \texttt{ENDIF}. Si es falsa se continúa en la siguiente sentencia a \texttt{ENDIF}. Si lleva nombre (opcional), debe ser un nombre válido en Fortran distinto de otras nombres en la unidad de alcance en la que está el bloque \texttt{IF}.


\subsection{Bloque {\tt ELSE-IF}}

La sitáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] IF (expres) THEN 
		bloq1 
	[ElSEIF (expres_i) THEN [nomb] b
		bloq_i]...
	[ELSE [nomb]
		bloq2]
	EDNDIF[nomb] 
\end{lstlisting}

Cada expresión {\tt expres, expres\_i} debe ser escalar lógica. Si {\tt expres} es verdadera se ejecutan las sentencias del bloque {\tt bloq1} entre {\tt THEN} y el primer {\tt ELSEIF} y se pasa a la siguiente sentencia a \texttt{ENDIF}. Si \texttt{expres\_i} es falsa se inspeccionan en orden las expresioens \texttt{expres\_i} hasta que una sea verdadera, en cuyo caso se ejecutan las sentencias del bloque {\tt bloq\_i} correspondiente y el control pasa a la siguiente sentencia \texttt{ENDIF}. Si la expresión {\tt expres} y todas las expresiones {\tt expres\_i} son falsas, se ejecutan las sentencias del bloque \texttt{bloq2} entre {\tt ELSE} y {\tt ENDIF}. \\

Las sentencias {\tt ELSEIF} y {\tt ELSE} pueden llevar nombre sólo si sus sentencias {\tt IF} y {\tt ENDIF} llevan y, en estec aso debe ser el mismo. No se puede entrar en un bloque {\tt IF, THEN, ELSEIF} ni {\tt ELSE} desde fuera de él con sentencias {\tt GOTO}, aunque si se peude salir en cualquier lugar con la misma. En el siguiente código podemos ver un ejemplo del uso de este bloque para resolver una función definida a trozos.

\begin{lstlisting}[language=Fortran]
	REAL x, f
	PRINT*,'valor de x =' ; READ*, x
	IF (0<=x .AND. x<=1) THEN
		f = 3*x**2 - 1
	ELSEIF (5<=x .AND. x<=10) THEN
		f = 6*x + 4
	ELSEIF (20<=x .AND. x<=40) THEN
		f = -7*x + 1
	ELSE
		f = 0
	ENDIF
	PRINT*, ' x = ', x, ' f = ', f
	END
\end{lstlisting}


\subsection{Selector {\tt SELECT CASE}}

La sintaxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] SELECT CASE (expres) 
	CASE (selector) [nomb]
		bloq... 
	CASE DEFAULT [nomb]
		bloq0... 
	ENDSELECT [nomb]
\end{lstlisting}

La expresión {\tt expres} debe ser escalar de tipo entera, lógica ({\it poco interesante}) ó carácter y los valores dados deben ser del mismo tipo (en el caso carácter las longitudes pueden ser diferentes pero no la clase, en los casos entero o lógico pueden ser diferentes). Si el valor {\tt expres} pertenece a un selector se ejecuta su bloque de sentencias y se continúa en la siguiente sentencia a  {\tt END SELECT}. Si no pertenece a ningún selector se ejecutan las sentencias del bloque \texttt{CASE DEFAULT}, si está presente y si no lo está se continúa en la siguiente sentencia a {\tt END SELECT}. \\

Si lleva nombre (opcional) debe ser un nombre válido en Fortran y distinto de otros nombres en la unidad de alcance en qeu se encuentra el bloque {\tt SELECT}. Las sentencias \texttt{CASE} y \texttt{CASE DEFAULT} pueden llevar nombre sólo si las sentencias {\tt SELECT CASE} y {\tt CASE} correspondientes lo llevan y, en este caso, debe ser el mismo. Los valores de los selectores han de ser disjuntos. Se separan por comas y puede especificarse un rango de valores, también disjuntos en cada selector. No se puede entrar en un bloque {\tt SELECT} ó {\tt CASE} desde fuera de él con sentencias {\tt GOTO}. Se puede salir en cualquier lugar con sentencias {\tt GOTO}. Los bloques {\tt SELECT CASE} pueden anidarse. \\

La diferencia principal entre los bloques {\tt IF} y {\tt CASE} es que en {\tt CASE} sólo se evalúa una expresión cuyo valor deb estar en un conjunto predefinido de valores, mientras que en {\tt IF} se pueden evaluar varias expresiones de naturaleza distinta. Veamos un ejemplo para entender mejor el problema:

\begin{lstlisting}[language=Fortran]
	CHARACTER car! equivale a CHARACTER(LEN=1) car
	INTEGER indice
	PRINT*, ' Introducir un caracter'
	READ*, car
	SELECT CASE (car)
	CASE ('a', 'e', 'i', 'o', 'u')
		PRINT*, ' Vocal minuscula : ', car
	CASE ('A', 'E', 'I', 'O', 'U')
		PRINT*, ' Vocal MAYUSCULA : ', car
	CASE ('b':'d', 'f':'h', 'j':'n', 'p':'t', 'v':'z')
		PRINT*, ' Consonante minuscula : ', car
	CASE ('B':'D', 'F':'H', 'J':'N', 'P':'T', 'V':'Z')
		PRINT*, ' Consonante MAYUSCULA : ', car
	CASE ('0':'9')
		PRINT*, ' Cifra del 0 al 9 : ', car
	CASE DEFAULT
		PRINT*, ' El caracter no es ni letra ni numero : ', car
	ENDSELECT

	PRINT*, ' Introducir un numero'
	READ*, indice

	SELECT CASE (indice)
	CASE (2, 3, 5, 7, 11, 13, 17, 19)
		PRINT*, ' Numero primo menor que 20 : ', indice
	CASE (20:29, 40:49, 60:69, 80:89)
		PRINT*, ' Numero menor que 100 con decena par : ', indice
	CASE (100:999)
		PRINT*, ' Numero de 3 cifras : ', indice
	CASE DEFAULT
		PRINT*, ' Resto de casos : ', indice
	ENDSELECT
	END
	
\end{lstlisting}

\subsection{Interacciones {\tt DO}}

La sintaxis es:

\begin{lstlisting}[language=Fortran]
	[nomb:] Do [,] var = expres1, expres2, expres3 
		bloq
	ENDDO [nomb]
\end{lstlisting}

La variable {\tt var} y las expresiones {\tt expres1, expres2, expres3} (esta última opcional) deben ser escalares enteras. La variable {\tt var} toma el valor inicial de {\tt expres1}, se ejecutan las sentencias {\tt bloq} del bloque {\tt DO}; {\tt var} se incrementa en {\tt expres3}, se ejecutan las sentencias del bloque {\tt DO}, y así sucesivamente hasta que {\tt var$>$expres2} (si {\tt expres3$>$0} ó  {\tt var$<$expres2} (si {\tt expres3$<$0}) en cuyo caso se continúa en la siguiente sentencia a {\tt ENDDO}. \\

El número de interacciones que se realizan en el bloque {\tt Do} (si no se sale de él antes de terminar) es: {\tt MAX\{ (expres2-expres1+expres3)/expres3,0 \}}. Cuando \{ {\tt expres1$>$expres2} y {\tt expres3$>$0} \}  ó \{ {\tt expres1$<$expres2} y {\tt expres3$<$0} \}  no se ejecuta el bloque {\tt DO}. Si {\tt expres1} y/ó {\tt expres2} y/ó {\tt expres3} son expresiones que incluyen variables, el valor de éstas puede cambiarse dentro del bloque  {\tt DO} y esto no altera el número de interaciones (calculado con sus valores iniciales). Ejemplo:

\begin{lstlisting}[language=Fortran]
	INTEGER, PARAMETER:: n=100000
	REAL x(n), suma1, suma2, suma3

	DO i = 1, n
		x(i) = 1.0/i
	ENDDO
	
	suma1 = 0.0
	DO i = 1, n
		suma1 = suma1 + x(i)
	ENDDO
	suma2 = 0.0
	DO i = n, 1, -1
		suma2 = suma2 + x(i)
	ENDDO
	PRINT*, ' suma1 = ', suma1, ' suma2 = ', suma2

	suma3 = 0
	DO i = 1, 100000, 3 ! i toma los valores 1, 4, 7,...
		IF (suma3 <= 5) THEN
			suma3 = suma3 + x(i)
		PRINT*, ' i =', i, ' suma3 = ', suma3
		ELSE
			PRINT*, ' suma3 > 5'
		STOP
		ENDIF
	ENDDO
	
	END
\end{lstlisting}




\subsection{{\tt DO} ilimitado, {\tt EXIT} y {\tt CYCLE}}

El {\tt DO} ilimitado tiene la siguiente sintaxis:

\begin{lstlisting}[language=Fortran]
	[nomb:] Do 
		bloq
	ENDDO [nomb]
\end{lstlisting}
Y la acción del mismo es que se repitan las sentencias {\tt bloq} indefinidamente, pudiendo salir del mismo con las sentencias {\tt EXIT} y {\tt GOTO}. \\


La sentencia {\tt EXIT[nomb]} dentro de un bloque {\tt Do} transfiere el control a la primera sentencia ejecutable después del {\tt ENDDO} a que se refiere, sino se indica el nombre {\tt nomb}, transfiere el control al {\tt ENDDO} del bloque más interior en el que está contenida. \\ 


La sentencia {\tt CYCLE[nomb]} dentro de un bloque {\tt Do} transfiere el control a la sentencia {\tt ENDDO} a que se refiere, sino se indica el nombre {\tt nomb}, transfiere el control al {\tt ENDDO} del bloque más interior en el que está contenida. 


\section{Utilidades de programa. Procedimientos.}

\subsection{Programa principal}

Un programa completo debe tener exactamente un programa principal. La forma es la siguiente:

\begin{lstlisting}[language=Fortran]
	PROGRAM [nombreprog]
		[sentencias de especificacion]
		[sentencias ejecutables]
	CONTAINS
		[subprogramas internos	]
	END PROGRAM [nombreprog]	
\end{lstlisting}

\subsection{Subprogramas externos}

Son llamados desde el programa principal o desde otros subprogramas. Pueden ser funciones o subrutinas. Ambas pueden ser recursivas, esto es, llamarse a sí mismas. No obstante esto es muy complejo, y su uso implica peor eficacia computacional. 

\subsection{Uso no recursivo de subprogramas {\tt FUNCTION}}

La sitaxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[tipo] FUNCTION nombfun ([argumentos ficticios])
		[sentencias de especificacion]
		[sentencias ejecutables]
	END [FUNCTION [nombreprog]]
\end{lstlisting}

Con esto estaríamos definiendo el subprograma {\tt FUNCTION nombfun}, invocándose con {\tt nombfun([argumentos actuales])}, y substituyendose los argumentos actuales en los ficticios y se evalúa la función. El valor asignado a {\tt nombfun} es el valor devuelto a la función. Téngase en cuenta que:

\begin{itemize}
	\item El término {\tt tipo} es opcional. Si se omite se toma el tipo por defecto o el que haya sido establecido por sentencias {\tt IMPLICIT}. 
	\item La llamada puede formar parte de una expresión o sentencia más larga. Un subprograma {\tt FUNCTION} puede contener cualquier sentencia excepto: {\tt PROGRAM, FUNCTION, SUBROUTINE} y {\tt BLOCK DATA}.
	\item La última sentencia tiene que ser {\tt END}. 
	\item Las variables y etiquetas en un subprograma {\tt FUNCTION} son locales, esto es, independientes del programa principal y las de otros subprogramas. 
	\item Los argumentos actuales deben coincidir en cantidad, orden, tipo y longitud con los argumentos ficticios. Puede no haber argumentos.
	\item Los argumentos actuales pueden modificarse: sin embargo, esta opción es especialmente desaconsejable. 
	\item Una función no recursiva no puede llamarse a sí misma ni directa ni indirectamente, pero sí puede llamar a otros subprogramas.
\end{itemize}

\subsubsection{Sentencia {\tt RETURN} en Subprogramas {\tt FUNCTION}}

{\tt RETURN} termina la ejecución de la función y devuelve el control a la unidad de programa que llamó a la función. Si la función no tiene sentencias {\tt RETURN} su ejecución termina al llegar a la sentencia {\tt END}. Puede ser una setntencia con etiqueta, y puede formar parte de una sentencia {\tt IF}.

\subsection{Uso no recursivo de Subprogramas {\tt SUBROUTINE}}

La sintaxis escalar

\begin{lstlisting}[language=Fortran]
	SUBROUTINE nombsubr ([argumentos ficticios])
		[sentencias de especificacion]
		[sentencias ejecutables]
	END [SUBROUTINE [nombresubr]]
\end{lstlisting}

La llamada a la subrutina se realiza mediante la sentencia {\tt CALL nombsubr [(argumentos actuales)]}, substituyendose los argumentos actuales en los ficticios. Las normas son las siguientes:

\begin{itemize}
	\item La llamada puede formar parte de una expresión o sentencia más larga. Un subprograma {\tt FUNCTION} puede contener cualquier sentencia excepto: {\tt PROGRAM, FUNCTION, SUBROUTINE} y {\tt BLOCK DATA}.
	\item La última sentencia tiene que ser {\tt END}. 
	\item Las variables y etiquetas en un subprograma {\tt FUNCTION} son locales, esto es, independientes del programa principal y las de otros subprogramas. 
	\item Los argumentos actuales deben coincidir en cantidad, orden, tipo y longitud con los argumentos ficticios. Puede no haber argumentos.
	\item Una función no recursiva no puede llamarse a sí misma ni directa ni indirectamente, pero sí puede llamar a otros subprogramas.
\end{itemize}

\subsubsection{Sentencia {\tt RETURN} en Subprogramas {\tt SUBROUTINE}}

{\tt RETURN} termina la ejecución de la subrutina y devuelve el control a la unidad de programa que llamó a la función. Si la subrutina no tiene sentencias {\tt RETURN} su ejecución termina al llegar a la sentencia {\tt END}. Puede ser una setntencia con etiqueta, y puede formar parte de una sentencia {\tt IF}.

\subsection{Argumentos de subprogramsas externos}

Los argumentos de un subprograma {\tt FUNCTION} O {\tt SUBROUTINE} pueden ser de naturaleza muy diversa: constantes o variables escalares, arrays o elementos de arrays, nombres de otros subprogramas, etc. Es necesario suministrar al compilador la información adecuada para identificar correctamente la naturaleza del argumento. 

\subsubsection{Propósito de los argumentos}

Los argumentos ficticios pueden tener una declaración de propósito de entrada salida o entrada/salida. El propósito se declara con el atributo {\tt INTENT}. 

\begin{itemize}
	\item {\tt INTENT (IN)}: declara un argumento de entrada. No debe cambiarse su valor dentro del subprograma. 
	\item {\tt INTENT (OUT)}: declara un argumento de salida. El argumento actual debe ser una variable y se vuelve indefinida en entrada.
	\item {\tt INTENT (IN/OUT)}: declara un argumento de entrada o salida. El argumento actual debe ser una variable.
\end{itemize}

Es recomendable declarar el propósito de los argumentos ficticios, lo cual ayuda a la documentación del programa y a las verificaciones durante la compilación.



\subsection{Sentencia {\tt EXTERNAL}}

Se escribe como {\tt EXTERNAL lista}, e identifica los nombres de {\tt lista} como subprogramas (funciones o subrutinas) externos definidos por el usuario. Al ser una sentencia de especificación, debe preceder a las  ejecutables y a las declaraciones de funciones. Cuando un argumento de un subprograma es el nombre de otro subprogarama, se debe declarar {\tt EXTERNAl} en su unidad de llamada. Si una función intrínseca se declara {\tt EXTERNAL} pierde su definición intrínseca en la unidad de programa asociada y se usa el subprograma del usuario. 


\begin{lstlisting}[language=Fortran]
	EXTERNAL fun1, fun2, sin
	x=1.5; n=3
	CALL ameba (x, n, y1, fun1)		! y1 = x**(5-n) = 2.25
	CALL ameba (x, n, y2, fun2)	 	! y2 = 3*x*(5-n) = 9
	s = sin (y1, y2, 6.0, x)			! s = y2/y1 + 6/x = 8
	PRINT*, y1, y2, s
	END

	SUBROUTINE ameba (x, n, y, f)
		y = f(x, 5, n)
	END

	FUNCTION fun1 (x, i, j)
		fun1 = x**(i-j)
	END

	FUNCTION fun2 (x, i, j)
		fun2 = 3*x*(i-j)
	END

	FUNCTION sin (a, b, c, d)
		sin = b/a + c/d
	END
\end{lstlisting}

\subsection{Sentencia {\tt INTRINSIC}}

La sintaxis {\tt INTRINSIC lista} declara los nombres de {\tt lista} como funciones intrínsecas. Las normas son
\begin{itemize}
	\item Los nombres de la {\tt lista} deben ser funciones intrínsecas.
	\item Si un argumento de un subprograma es una función intrínseca se debe declarar {\tt INTRINSIC} en la unidad de llamada. 
	\item Si un nombre está en una sentencia {\tt INTRINSIC} no puede estar en una sentencia {\tt EXTERNAL}.
\end{itemize}

\begin{lstlisting}[language=Fortran]
	INTRINSIC sin, cos, exp
	a=3.141592; b=-a
	r = fun (sin, cos, exp, a, b, 4)
	PRINT*, r
	END

	FUNCTION fun (f1, f2, f3, a, b, n) ! fun = (sin(a)+cos(b)+
	fun = (f1(a) + f2(b) + f3(a+b)) ** n ! exp(a+b))**n	
	END
\end{lstlisting}

\subsection{Subprogramas internos}

Son subprogramas contenidos en el programa principal, en un subprograma externo o en un módulo. Su uso es adecuado, a efectos de organización, para subprogramas cortos (del orden de unas 20 líneas), que sólo se necesitan en un único programa, subprograma o módulo.  La sintáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	CONTAINS
	subprogramas internos
\end{lstlisting}
Y las normas son:

\begin{itemize}
	\item Los subprogramas internos deben aparecer entre la sentencia {\tt CONTAINS} y la sentencia {\tt END} de la unidad de programa a la que pertenezcan. 
	\item Un subprograma interno no puede contener a otro subprograma interno.
	\item Un subprograma interno sólo puede llamarse desde su host.
	\item Un host conoce todo acrca de la interface con sus subprogramas internos, por tanto no hace falta declarar el tipo en el host para una función interna.
	\item Un subprograma interno tiene acceso a las variables del host.
	\item El host no tiene acceso a las variables locales de los subprogramas internos.
	\item La sentencia {\tt IMPLICIT NONE} en un host afecta al host y también a sus subprogramas internos. 
	\item Las etiquetas son locales. Si una sentencia tiene etiqueta, ésta debe estar en la misma unidad de alcance que la sentencia que la referencia.
\end{itemize}

\begin{lstlisting}[language=Fortran]
	PROGRAM interno
		CALL coefbinomial ! invoca una subrutina interna

	CONTAINS

		SUBROUTINE coefbinomial
			INTEGER n, k
			CALL leer(n) ! invoca una subrutina interna
			DO k = 0, n
				PRINT*, k, nsobrek(n,k) ! invoca una funcion interna
			ENDDO
		ENDSUBROUTINE coefbinomial

		SUBROUTINE leer(n)
			INTEGER n
			PRINT*, ' Introducir el valor de n'
			READ*, n
		ENDSUBROUTINE leer

		FUNCTION nsobrek(n,k)
			INTEGER nsobrek, n, k
			nsobrek = fact(n) / (fact(k)*fact(n-k)) ! invoca una funcion
		ENDFUNCTION nsobrek ! interna 3 veces

		FUNCTION fact(m)
			REAL fact
			INTEGER m, i
			fact = 1
			DO i = 2, m
				fact = i*fact
		ENDDO
		ENDFUNCTION fact

	ENDPROGRAM interno
\end{lstlisting}

Su principal utilidad es organizar mejor el código y permitir un mayor control sobre el ámbito de las variables, ya que los subprogramas internos solo pueden ser llamados desde el subprograma en el que están definidos. Las principales ventajas de los subprogramas internos son:

\begin{itemize}

	\item Encapsulamiento: Permiten encapsular la lógica auxiliar o funciones específicas que solo tienen sentido dentro del contexto del subprograma principal. Esto ayuda a mantener el código más legible y modular.

	\item Ámbito de variables: Las variables locales del subprograma externo pueden ser utilizadas directamente dentro del subprograma interno, lo que evita la necesidad de pasarlas como argumentos. Esto simplifica el manejo de variables cuando son comunes a ambos subprogramas.

	\item Modularidad: Facilita la descomposición de tareas complejas en tareas más simples, dividiendo la lógica en partes más manejables, lo que mejora la mantenibilidad del código.

\end{itemize}


\subsection{Módulos}

Un módulo permite empaquetar definiciones de datos y compartir datos entre diferentes unidades de programas que pueden incluso compilarse por separado. Sirve, especialmente, para crear grandes librerías de software. En su uso sencillo:

\begin{itemize}
	\item Ofrece posibilidades similares a {\tt INCLUDE}.
	\item Permite compartir datos en ejecución.
	\item Sirve para inicializar variables.
\end{itemize}

La sitátxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	MODULE nombmod
		[sentencias de especificacion]
	ENDMODULE nombmod
\end{lstlisting}
Y las normas

\begin{itemize}
	\item Se puede acceder a un módulo desde el programa principal, un subprograma u otro módulo. Se accede a las especificaciones y variables del módulo con los valores asignados (si los tienen). Las variables y datos de un módulo con los valores asignados si los tienen. Las variables y datos de un módulo tienen, por defecto, alcance {\bf global}, en todas las unidades desde las que se acceden con {\tt USE}.
	\item Desde un módulo se tiene acceso a las otras entidades del módulo incluyendo subprogramas. 
	\item Puede contener sentencias {\tt USE} para acceder a otros módulos.
	\item No debe acceder a sí mismo directamente o indirectamente a través de {\tt USE}.
	\item El módulo debe compilarse antes que el programa que lo usa. En la sentencia compilación se crea un fichero {\tt *.mod} que es el que lee la sentencia {\tt USE}. Se recomienda que un módulo solo acceda a módulos anteriores a él.
\end{itemize}


\subsection{Orden de las sentencias}

Las diferentes sentencias que puede contener un programa de Fortran deben escribirse en el orden siguiente (tabla \ref{Tab:01-01}).

\begin{table}[h!] \centering
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{{\tt PROGRAM, FUNCTION, SUBROUTINE, MODULE}} \\ \hline
		\multicolumn{3}{|c|}{\texttt{USE}} \\ \hline
		\multirow{7}{*}{\texttt{FORMAT}} & \multicolumn{2}{l|}{\texttt{IMPLICIT NONE}}\\  \cline{2-3}
		 & \texttt{PARAMETER} & \texttt{IMPLICIT} \\  \cline{2-3}
		 & \multirow{4}{*}{\texttt{PARAMETER, DATA}} & Tipos derivados \\
		 &  & Bloques \texttt{INTERFACE} \\
		 &  & Declaración de tipos\\ 
		 &  & Sentencias de especificación \\  \cline{2-3}
		 &  \multicolumn{2}{l|}{Sentencias ejecutables}  \\ \hline
		\multicolumn{3}{|c|}{\texttt{CONTAINS}} \\ \hline
		\multicolumn{3}{|c|}{Subprogramas inteernos o subprogramas modulo} \\ \hline
		\multicolumn{3}{|c|}{\texttt{END}} \\ \hline
	\end{tabular}
	\caption{orden de las sentencias.}
	\label{Tab:01-01}
\end{table}

\section{Procedimientos intrínsecos}

Los procedimientos intrínsecos son funciones y subrutinas que forman parte del lenguaje Fortran estándar, suministradas con el compilador. En fortar 95 hay 109 funciones y 6 subrutinas que pueden clasificarse en cuatro categorías de procedimientos intrínsecos:

\begin{itemize}
	\item \textbf{Procedimientos elementales}: sus argumentos son escalares o arrayas. Si una función elemental se aplica a un array la función se aplica a cada elemento del array.
	\item \textbf{Funciones de interrogación}: devuelven propiedades de sus argumentos que no dependen de sus valores.
	\item \textbf{Funciones transformacionales}: suelen tener argumentos de arrays y resultados de arrays cuyos elementos dependen de muchos elementos del argumento.
	\item \textbf{Subrutinas no elementales}
\end{itemize}

Cada función devuelve un valor entero, real, complejo, lógico... de modo que tendremos que abreviar de algún modo el tipo de valor devuelto. En este caso usaremos que:


\begin{table}[h!] \centering
	\begin{tabular}{|c|c|}
		\hline 
		I & Entero \\ 
		\hline 
		R & Real \\
		\hline 
		N & Numerico  \\
		\hline 
		L & Logico \\
		\hline 
		CH & Carácter\\
		\hline 
	\end{tabular}
	\caption{tipo de variable.}
	\label{Tab:01-02}
\end{table}
\newpage

\subsection{Funciones elementales que convierten tipos}

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l} 
	Nombre & Definición &  Tipo argumentos & Tipo función \\ \hline
	ABS(x) & Valor absoluto & I & I \\
	ABS(x) & Valor absoluto & R & R  \\
	ABS(z) & Módulo complejo & C & R \\
	AIMAG(z) & Parte imaginaria & C & R \\
	AINT(x) & Quita decimales &  R & R \\
	ANINT(x) & Redondeo & R & R \\
	CEILING(x) & Redondeo  (por arriba) &  R & I \\
	CMPLX(x[,y]) & Pasa a complejo & N  & C \\
	FLOOR(x) & Redondeo (por abajo) & R  & I \\
	INT(x) & Pasa a entero & N & I \\
	NINT(x) & Redondeo entero  & R  & I \\
	DNINT(x) & Redondeo entero (doble precisión) & R  & I \\
	REAL(x) & Pasa a real & N & R \\
	\end{tabular}
	\caption{funciones elementales que pueden convertir tipos.}
	\label{Tab:01-03}
\end{table}

\subsection{Funciones elementales que no convierten tipos}


El resultado de las funciones elementales \ref{Tab:01-03} es del tipo de su primer argumento.

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición &  Tipo argumentos & Tipo función \\ \hline
		CONJG(z) & Conjugado complejo & C & C \\
		DIM(x,y) & Diferencia positiva & (I,I)  ó (R,R) & I ó R \\
		MAX(x1,x2,[,x3,...]) & Máximo & (I,I,…) ó (R,R,…)  & I ó R \\
		MIN(x1,x2,[,x3,...]) & Mínimo & (I,I,…) ó (R,R,…) & I ó R \\
		MOD(x,y) & Resto de x módulo y  & (I,I) ó (R,R) & I ó R \\
		MODULO(x,y)  & x módulo y & (I,I) ó (R,R) & I ó R \\ 
		SIGN(x,y) & Transferencia de signo & (I,I) ó (R,R) & I ó R \\
	\end{tabular}
	\caption{funciones elementales que no pueden convertir tipos.}
	\label{Tab:01-03}
\end{table}

\subsection{Funciones matemáticas elementales}

El resultado de las funciones elementales \ref{Tab:01-04} es del tipo de su primer argumento.

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición & Tipo argumentos & Tipo función \\ \hline
		ACOS(x) & Arco Coseno & R / $|x|\leq $1 & R en [0,$\pi$]  \\
		ASIN(x) & Arco Seno & R /  $|x|\leq $1 & R en [$-\pi/2$,$\pi/2$]  \\
		ATAN(x) & Arco Tangente & R & R en  [$-\pi/2$,$\pi/2$] \\
		ATAN2(y,x) & Argumento número complejo & (R,R) & R en  ($-\pi$,$\pi$] \\
		COS(x) & Coseno & R ó C & R ó C \\
		COSH(x) & Coseno hiperbólico & R & R \\
		EXP(x) & Exponencial & R ó C & R ó C \\
		LOG(x) & Logaritmo neperiano & R ó C & R ó C \\
		LOG10(x) & Logaritmo decimal  & R x$>$0 & R \\ 
		SIN(x) & Seno &  R ó C & R ó C \\
		SINH(x) & Seno hiperbólico & R & R \\
		SQRT(x) & Raíz cuadrada & R ó C & R ó C \\
		TAN(x)  & Tangente & R & R \\ 
		TANH(x) & Tangente hiperbólica &  R & R \\
	\end{tabular}
	\caption{funciones matemáticas elementales.}
	\label{Tab:01-04}
\end{table}


\subsection{Operaciones con matrices y vectores}

La función {\tt DOT\_PRODUCT(x,y)} requiere que x e y tengan una dimensión y el mismo tamaño. Si $x$ es entero o real devuelve $\sum x_i y_i$; si $x$ es complejo devuelve $\sum \overline{x}_i y_i$. Véase tabla \ref{Tab:01-05}.  \\

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición  & Tipo argumentos & Tipo función \\ \hline
		DOT\_PRODUCT(x,y) & Producto escalar real & (I ó R, I ó R) & I ó R \\
		DOT\_PRODUCT(z,y) & Producto escalar complejo & (C,I ó R) & C \\
		MATMUL(a,b) & Producto matricial & (N,N) & N \\
		TRANSPOSE(a) & Matriz traspuesta & N & N 
	\end{tabular}
	\caption{}
	\label{Tab:01-05}
\end{table}

La función  {\tt MATMUL(a,b)} devuelve un array de dos dimensiones en función de la forma de los dos arrays según la tabla \ref{Tab:01-06}.


\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Operación & Forma de a & Forma de b & Forma de MATMUL(a,b) \\ \hline
		Matriz x Matriz & (n,m) & (m,k) & (n,k) \\
 		Vector x Matriz & (m) & (m,k) & (k) \\
		Matriz x Vector & (n,m) & (m) & (n) \\
	\end{tabular}
	\caption{}
	\label{Tab:01-06}
\end{table}

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición &  Tipo argumentos & Tipo función \\  \hline
		MAXVAL(x) & Máximo elemento & I ó R & I ó R \\
		MINVAL(x) & Mínimo elemento & I ó R & I ó R \\
		PRODUCT(x) & Producto de los elementos & I ó R & I ó R \\
		SUM(a) & Suma de los elementos & I ó R & I ó R
	\end{tabular}
	\caption{}
	\label{Tab:01-07}
\end{table}
\newpage

\subsection{Números aleatorios}

La sintaxis para llamar a números aleatorios es la siguiente {\tt CALL RANDOM\_NUMBER ([HARVEST=]aleat)}, donde {\tt aleat} es un argumento real (escalar o array), devolviendo números seudoaleatorios en {\tt aleat} en el rango [0,1). \\

El otro tipo de forma de obtener un número aleatorio es usar {\tt CALL RANDOM\_SEED ([SIZE],[PUT],[GET])}, donde los argumentos son:

\begin{itemize}
	\item {\tt SIZE}: variable escalar {\tt INTEGER}. Variable de salida que contiene el tamaño {\tt N} del array semilla.
	\item {\tt PUT}: array {\tt INTEGER} de dimensión ({\tt N}). Variable de entrada utilizada para establecer la semilla.
	\item {\tt GET}: array {\tt INTEGER} de dimensión ({\tt N}). Variable de salida que contiene el valor actual de la semilla.
\end{itemize}
Si no se especifica una semmilla se establece una semilla que depende del procesador. Veamos un ejemplo de donde usamos los números aleatorios y el tiempo de cálculo:

\begin{lstlisting}[language=Fortran]
	PROGRAM aleatorio 
	INTEGER t1(8), t2(8)
	INTEGER i, numrep, semilla(1)
	REAL x, sx, tdif
	CHARACTER(LEN=8) date1, date2
	CHARACTER(LEN=10) time1, time2
	CHARACTER(LEN=5) zona

	PRINT*, ' numero de repeticiones'
	READ*, numrep
	PRINT*, ' semilla inicial'
	READ*, semilla
	CALL RANDOM_SEED (PUT=semilla)

	CALL DATE_AND_TIME (VALUES=t1, DATE=date1, ZONE=zona, TIME=time1)
	DO i = 1, numrep
		CALL RANDOM_NUMBER (x)
		sx = SIN(x)
	ENDDO

	CALL DATE_AND_TIME (VALUES=t2, TIME=time2, DATE=date2)

	PRINT*, ' zona=', zona
	PRINT*, ' date1=', date1, ' date2=', date2
	PRINT*, ' time1=', time1, ' time2=', time2

	tdif = 0.001*(t2(8)-t1(8)) + (t2(7)-t1(7)) + 60.*(t2(6)-t1(6)) + &
		3600.*(t2(5)-t1(5))
	PRINT*, ' tdif =', tdif

	ENDPROGRAM aleatorio
\end{lstlisting}



\section{Entrada y salida de datos. Ficheros. Formatos.}


\subsection{Elementos y clases de ficheros}

Los conceptos fundamentales a considerar son: campos, registro y fichero. 

\begin{itemize}
	\item \textbf{Campo:} unidad de información que consta de varios caracteres que se tratan en conjunto.
	\item \textbf{Registro:} conjuto de campos, no necesariamente del mismo tipo.
	\item \textbf{Fichero:} conjunto de registros, no necesariamente con igual estructura.
\end{itemize}
Como ejemplo un fichero de personas podría contener un registro por cada persona y los campos podrían ser: nombre, DNI, dirección, edad, teléfono\dots En algunos casos, por ejemplo en las bases de datos, los registros de un fichero tienen la misma estrucutra, esto es, el mismo número y forma de los campos. Los tipos de {\bf acceso} a un fichero en Fortran son secuencial o directo:

\begin{itemize}
	\item \textbf{Secuencial:} para acceder a un registro hay que recorrer todo el fichero desde el principio hasta llegar a él.
	\item \textbf{Directo:} conociendo el número de orden de un registro en el dichero se puede acceder a él sin tener que recorrer los registros anteriores.
\end{itemize}

Los datos pueden almacenarse en \textbf{forma} formateada o no formateada:

\begin{itemize}
	\item \textbf{Formateada}: la información se guarda como caracteres ASCII, legibles con la mayoría de los procesadores de texto.
	\item \textbf{No formateada}: un fichero es una serie de registros formados por ``bloques físicos''.
\end{itemize}

\subsection{Lectura y escritura de datos}

Internamente el ordenador representa los números y caracteres con cierta codificación. Para poder interpretar unos datos de entrada o mostrar unos datos de salida de forma legible se hacen conversiones entre la representación interna y la externa mediante especificaciones de formato. \\

Las entidades a leer o escribir se llaman listas de entrada/salida (lista I/O). En entrada se deben leer variables, en salida pueden escribirse expresiones. Si un array está en una lista I/O, se consideran todos los elementos del array en el orden de un almacenamiento del array. Una lista puede contener un DO implícito de variables.  \\

Existen 3 formas de indicar el formato de los datos a leer o escribir:

\begin{itemize}
	\item Sentencia {\tt FORMAT} con etiqueta.
	\begin{itemize}
		\item Sintaxis: {\tt e FORMAT (codform)} 
		\item Acción: {\tt codform} especifica los códigos de formato de lectura o escritura. 
		\item Normas: {\tt e} es un número de etiqueta. Es una sentencia no ejecutable.
	\end{itemize}
	\item Una expresión carácter que contiene el formato entre paréntesis.
	\item Un asterisco * que indica formato libre (lista directa de entrada-salida).
\end{itemize}

Cada fichero {\bf externo} (terminal, impresora, fichero en disco ó en cinta...) del qeu se lee o en el qeu se escribe lleva asociado un número de unidad no negativo, generalmente en el rango 1 a 99. Un número de unidad {\tt u} asociado a un fichero externo puede ser:

\begin{itemize}
	\item Una expresión entera con valor admisible (generalmente $1\leq u \leq 99$).
	\item Un asterisco: entrada/salida estándar por defecto (generalmente teclado y pantalla).
\end{itemize}

Toda la sentencia de lectura o escritura en un fichero externo debe referirse explícitamente a su número de unidad asociado. Hay dos excepciones:

\begin{itemize}
	\item Sentencia {\tt READ} sin número de unidad.
	\begin{itemize}
		\item Sintaxis: {\tt READ} sin número de unidad.
		\item Acción: lee datos del teclado (en modo interactivo). {\tt fmt} indica el formato.
	\end{itemize}
	\item Sentencia {\t PRINT}
	\begin{itemize}
		\item Sintaxis: {\tt PRINT fmt [,listavar]}
		\item Escribe los datos en la pantalla (en modo interactivo) con el formato {\tt fmt}.
	\end{itemize}
\end{itemize}

\subsection{Acceso a ficheros externos}

\subsubsection{Sentencia \texttt{OPEN}}

La sintáxis elemental es 
\begin{lstlisting}[language=Fortran]
	OPEN ([UNIT=]u,FILE=nbf)
\end{lstlisting}
Conecta la unidad {\tt u} al fichero \texttt{nbf} (``abre'' la unidad {\tt u}). La palabra clave {\tt UNIT=} es opcional; {\tt u} es una expresión entera. Por defecto el fichero se considera secuencial formateado.  {\tt nbf} es una expresión carácter que proporciona el nombre del fichero.

\begin{lstlisting}[language=Fortran]
	CHARACTER(LEN=30) nomb
	nfile = 3; nf = 3; nomb = 'cilindro.sal'
	OPEN (UNIT=3, FILE='cilindro.sal') ! estas cuatro sentencias
	OPEN (3, FILE='cilindro.sal') ! son equivalentes
	OPEN (nfile, FILE='cilindro.sal') ! si nfile=3
	OPEN (nf, FILE=nomb) ! si nf=3, nomb='cilindro.sal'
	WRITE (3,'(A)') ' El fichero 3 ha sido abierto'
	END
\end{lstlisting}

En raras ocasiones se leen y escriben datos en un mismo fichero. Normalmente, los datos de entrada se leen de ficheros que no se desean modificar y los resultados se escriben en ficheros nuevos o se añaden a ficheros ya existentes o sustituyen la información previa en ficheros existentes. Además de {\tt UNIT=u} y {\tt FILE=nbf} la sentencia {\tt OPEN} admite numerosos especificadores.

\subsubsection{Sentencia \texttt{CLOSE}}


La sintáxis elemental es 

\begin{lstlisting}[language=Fortran]
	CLOSE ([UNIT=]u)
\end{lstlisting}
Desconecta la unidad {\tt u} (``cierra'' la unidad {\tt u}). La palabra clave {\tt UNIT=} es opcional; {\tt u} es una expresión entera. Por defecto, si el programa termina normalmente se cierran todos los ficheros. Esta sentencia es útil si hay que tener abiertos A LA VEZ bastantes ficheros, ya que el número máximo de ficheros abiertos simultáneamente peude ser muy limitado.


\subsection{Entrada y salida formateada}

La entrada y salida sin número de unidad ya se ha descrito. 

\subsubsection{\texttt{READ} con número de unidad}


La sintáxis elemental es 

\begin{lstlisting}[language=Fortran]
	READ ([UNIT=]u,  [FMT=]fmt [,IOSTAT=ios] [,ERR=e1] [,END=e2]) listavar
\end{lstlisting}
Lee los datos del fichero asociado a la unidad {\tt u} según el formato {\tt fmt} y los asigna a los itmes de {\tt listavar}.

\begin{itemize}
\item {\tt u} puede ser una expresión entera, un asterisco o el nombre de un fichero interno.
\item {\tt fmt} puede ser un número de etiqueta de una sentencia {\tt FORMAT}, una lista de códigos de formato entre apóstrofos (si un carácter de esta lista es un apóstrofo hay que duplicarlo).
\item {\tt IOSTAT=ios} es opcional. {\tt ios} es una variable escalar entera que tomará un valor negativo si ocurre un fin de registro, otro valor negativo distinto si ocurre un fin de fichero y un valor positivo si ocurre alguna condición de error. Valdrá 0 si no hay error en la lectura.
\item {\tt ERR=e1} (opcional); si se produce un error de lectura se continúa en la
sentencia con etiqueta {\tt e1}, si no está {\tt ERR=e1} se para la ejecución.
\item {\tt END=e2} (opcional); si se intenta leer después del fin del fichero se continúa en la sentencia con etiqueta {\tt e2}, si no está {\tt END=e2} se para la ejecución.
\item {\tt listavar} es una lista de variables separadas por comas
\end{itemize}


\subsubsection{\texttt{WRITE} con número de unidad}


La sintáxis elemental es 

\begin{lstlisting}[language=Fortran]
	WRITE ([UNIT=]u,  [FMT=]fmt [,IOSTAT=ios] [,ERR=e1]) listavar
\end{lstlisting}
Escribe los datos de {\tt listavar} en el fichero asociado a la unidad {\tt u} según el formato {\tt fmt}. El significado de los parámetros es el mismo que en la sentencia {\tt READ}.


\subsection{Códgigos de formato}

Los códigos de formato, también llamados descriptores de edición, indican como se realiza la conversión entre las representaciones interna y externa de los datos mediante las sentencias {\tt READ, WRITE} Y {\tt PRINT}. Se clasifican en tres grupos:

\begin{itemize}
	\item Para datos:
	\begin{table}[h!] \centering
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		Enteros & Reales & Lógicos & Caractéres & Generales \\ \hline
		\texttt{I, B, O, Z} & \texttt{F, E, EN, ES, D} &  \texttt{L} & \texttt{A} & \texttt{G} \\ \hline
	\end{tabular}
	\end{table}
	\item Para literales: uso de comillas.
	\item Para control:
	\begin{table}[h!] \centering
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		Posicion & Espacios & Signos & Escala & Fin de formato \\ \hline
		\texttt{X,T,TR,TL} & \texttt{BN, BZ} &  \texttt{S, SP, SS} & \texttt{P} & \texttt{:} \\ \hline
	\end{tabular}
	\end{table}
\end{itemize}

Significado de los valores {\tt w, m, d, e, k, n, r}:

\begin{itemize}
	\item {\tt w}: establece la anchura del campo.
	\item {\tt m}: indica la menos $m$ cifras en el campo.
	\item {\tt d}: indica el número de cifras decimales en el campo.
	\item {\tt e}: indica el número de cifras del exponente.
	\item {\tt k}: es el factor de escala.
	\item {\tt n}: indica la posición en el registro desde su principio (para el descriptor  {\tt T}).
	\item {\tt n}: número de espacios a mover (para los descriptores {\tt X, TR, TL}).
	\item {\tt r}: factor opcional de repetición, por defecto vale 1.
\end{itemize}
Con las restricciones: \texttt{w>0, e>0, 0$\leq$m$\leq$w, 0$\leq$d$\leq$w, 0$\leq$e$\leq$w, n$\geq$1, r$\geq$1, k$\geq$0.}
 
\subsubsection{Normas de edición de códigos de formato}

\begin{itemize}
	\item En fortran 95, \texttt{w} puede ser 0 para salida en los códigos \texttt{I, B, O, Z, F} y entonces la salida tendrá la anchura mínima necesaria para contener el dato asociado.
	\item Los descriptores de edición se separan por comas, las cuales pueden omitirse en los siguientes casos:
	\begin{itemize}
		\item Entre el fator de escala {\tt P} y los códigos \texttt{F, E, EN, ES, D, G}.
		\item Antes de / (si no lleva factor de repetición).
		\item Después de /
		\item Antes o después de :		
	\end{itemize}
	\item Pueden ponerse espacios en cualquier lugar del formato.
	\item Los descriptores de edición pueden anidarse entre paréntesis.
	\item El factor de opcional de repetición {\tt r} es una constante entera positiva opcional que puede preceder a los siguientes códigos de formato: los da datos, los espacios, {\tt X}, la barra /, y grupos de código entre paréntesis. 
\end{itemize}
\subsubsection{Normas de trasferencia de códigos de formato}

Cuando se alcanza el útilmo paréntesis derecho de una especificación completa de formato se procede de la siguiente forma

\begin{itemize}
	\item Si no hay más items en la lista I/O, termina la trasferencia de datos.
	\item Si la lista I/O tiene más items que cantidad de códigos de formato contando las repeticionesw:
	\begin{itemize}
		\item Si hay paréntesis interiores con código de formato, el control de formato vuelve al principio del paréntesis izquierdo correspondiente al último paréntesis derecho precedente con su factr de repetición si lo tiene y se salta al siguiente registro.
		\item Si no hay paréntesis interiores con códigos de formato el control vuelve al principio de formato y se salta al siguiente registro.
	\end{itemize}
\end{itemize}

\subsubsection{Codigo para datos enteros}

Sintaxis:

\begin{lstlisting}[language=Fortran]
	[r]Iw[.m] 
\end{lstlisting}
donde {\tt w} es la anchura del campo. Se añaden ceros iniciales, si son necesarios, hasta completar {\tt m} caracteres. Ha de ser {\tt m$\leq$n}. Si en escritura faltan posiciones se imprimen asteriscos; si sobran se rellenan con espacios por la izquierda. Los códigos {\tt B, O, Z} se usan de manéra análoga.

\begin{lstlisting}[language=Fortran]
	OPEN (11, FILE='EJ7-10.dat')
	! OPEN (11, FILE='EJ7-10.dat', BLANK='ZERO') ! Opcional
	OPEN (12, FILE='EJ7-10.sal')
	READ (11, '(I6,3I2,I3,I4)') i, j, k, l, m, n
	WRITE (12, '(2I5,I4.2,I2,I2,I6.5)') i, j, k, l, m, n
	PRINT*, i, j, k, l, m, n
	END
	
! registro leido: b-2345b1b23b9871bb5 (por defecto los espacios se ignoran)
! asignaciones: i=-2345, j=1, k=2, l=3, m=987, n=15
! registro escrito: -2345bbbb1bb02b3**b00015
! salida en pantalla: b-2345b1b2b3b987b15
\end{lstlisting}	


\subsubsection{Codigo para datos reales}

Los códigos para datos reales dependen del códigoa a usar. Por ello debemos distinguir los 4 tipos de formas:

\begin{itemize}
	\item \textbf{Código} \texttt{F} \textbf{(datos reales sin exponente)}. En este caso la sintaxis es
	 
	\begin{lstlisting}[language=Fortran]
		[r]Fw.d
	\end{lstlisting}

	donde {\tt w} es la anchura del campo y {\tt d} número de decimales detrás del punto decimal. La entrada debe ser una constante entera o real; si lleva el punto decimal éste prevalece sobre la especificación {\tt d}. La variable de salida debe ser REAL o COMPLEJA. En salida, se debe reservar un espacio para el signo, el punto, la parte entera y los {\tt d} decimales. Si faltan posiciones se imprimen asteriscos; si sobran, se rellenan con espacios por la izquierda. Un dato complejo requiere dos códigos de formato para reales.

	\item \textbf{Código} \texttt{E} \textbf{(datos reales con exponente)}. En este caso la sintaxis es

	\begin{lstlisting}[language=Fortran]
		[r]Ew.d
	\end{lstlisting}

	donde {\tt w} es la anchura del campo y {\tt d} número de decimales detrás del punto decimal. La entrada se usa igual que en el código {\tt F}. Si faltan posiciones se imprimen asteriscos; si sobran, se rellenan con espacios por la izquierda. Se recomienda que {\tt n}$\geq${\tt d+7}.
	
	\item \textbf{Código} \texttt{D} \textbf{(datos reales con exponente d)}. En este caso la sintaxis es
	 
	\begin{lstlisting}[language=Fortran]
		[r]FD.d
	\end{lstlisting}

	donde {\tt w} es la anchura del campo y {\tt d} número de decimales detrás del punto decimal. La entrada se usa igual que en el código {\tt E}. En lectura sirve para leer datos en doble precisión. En escritura sirve para escribir datos con exponente {\tt d} que posteriormente sean leídos en doble precisión.

	\item \textbf{Código} \texttt{G} \textbf{(datos reales sin exponente)}. En este caso la sintaxis es
	
	\begin{lstlisting}[language=Fortran]
		[r]Gw.d
	\end{lstlisting}

	En entrada se usa igual que en el código {\tt E}. La salida es de tipo {\tt F} o {\tt E} dependiendo de la magnitud del dato.
\end{itemize}

\subsubsection{Codigo para datos lógicos}
En este caso la sintaxis es
	
\begin{lstlisting}[language=Fortran]
	[r]Lw
\end{lstlisting}

En entrada si el primer carácter no espacio es {\tt T} o {\tt .T} se asigna {\tt .TRUE.} al dato leído, si es {\tt F} o {\tt .F} se asigna {\tt .FALSE.}. En salida se escribe {\tt T} o {\tt F} precedida de {\tt w-1} espacios.

\subsubsection{Codigo para datos carácter}
En este caso la sintaxis es
	
\begin{lstlisting}[language=Fortran]
	[r]A[w]
\end{lstlisting}

Si se usa la {\tt A} forma sin especificar, {\tt w}, se leen o escriben un número de caracteres igual a la longitud del item correspondiente de la lista I/O. En entrada sea {\tt lon} la longitud del dato carácter a leer con formato {\tt Aw}. 

\begin{itemize}
	\item Si {\tt w} $\geq$ {\tt lon} se leen los {\tt lon} caracteres más a la derecha del campo.
	\item Si {\tt w} $<$ {\tt lon} se leen los {\tt w} caracteres, se asignan justificados por la izquierda al dato carácter y se completa con {\tt lon-w}.
\end{itemize}
En salidad sea {\tt lon} la longitud del dato carácter a escribir con formato {\tt Aw.}

\begin{itemize}
	\item Si {\tt w} $>$ {\tt lon} se escriben {\tt w-lon} espacios seguidos de {\tt lon} caracteres del dato carácter.
	\item Si {\tt w} $\leq$ {\tt lon} se escriben los {\tt w} caracteres iniciales del dato carácter.
\end{itemize}

\subsection{Codigos de control}

Existen diferentes tipos de códigos de control:

\begin{itemize}
	\item \textbf{Espacio:} {\tt nX}. En entrada salta {\tt n} caractéres sin cambiar de registro. En salida deja {\tt n} espacios en blanco antes de escribir el próxmo item.
	\item \textbf{Tabulación absoluta:} {\tt Tn}. Sitúal a posición de lectura/escritura justo antes de a columna {\tt n} del registro actual, repsecto al límtie de tabulación permitida.
	\item \textbf{Tabulación a la derecha:} {\tt TRn}. Sitúa la posición de lectura/escritura {\tt n} columnas a la derecha a partir de la actual en el registro actual.
	\item \textbf{Tabulación a la izquierda:} {\tt RLn}. Sitúa la posición de lectura/escritura {\tt n} columnas a la izquierda a partir de la actual en el registro actual, con el límite de la tabulación izquierda.
	\item \textbf{Salto de registro:} {\tt /}. Indica el fin de trasferencia de datos al (del) registro actual, esto es, se salta al principio del siguiente registro para leer o escribir. Si hay n barras / consecutivas al principio o al final de la sentencia {\tt FORMAT} se saltan {\tt n} registros; si están en el interior sólo {\tt n-1}.
	\item \textbf{Fin de formato:} {\tt :}. Si al llegar a los : no quedan más items en la lista I/O acaba el formato, si quedan más se ignoran los :. Es útil en salida.
	\item \textbf{Control de carro:} {\tt 'b', '0', '1', '+'}. Las sentencias de salida formateada fueron diseñadas en su origen para impresoras de líneas, con el concepto de línea y página. Cuando la sentencia {\tt WRITE} envía datos a una impresora, el primer carácter de cada registro se interpreta como control y no se imprime. El efecto del primer carácter es:
	
	\begin{itemize}
		\item {\tt b}: empieza en una nueva línea.
		\item {\tt 0}: salta una línea.
		\item {\tt 1}: avanza hasta el principio de la página siguiente.
		\item {\tt +}: no avanza, permanece en la misma línea.
	\end{itemize}
\end{itemize}
Es una buena práctica de programación insertar un blanco como primer carácter de cada registro cuando se envía a la pantalla o a una impresora. Puede hacerse comenzando los formatos por {\tt (1X,...} o por {\tt (T2,...}

\subsection{Posicionamiento de ficheros}

\subsubsection{Sentencia {\tt BACKSPACE}}

La sintaxis 

\begin{lstlisting}[language=Fortran]
	BACKSPACE ([UNIT=]u,  [FMT=]fmt [,IOSTAT=ios] [,ERR=e1] [,END=e2])
\end{lstlisting}
si el fichero conectado a la unidad {\tt u} está posicionado dentro de un registro se vuelve al principio del registro actual; si está posicionado entre registros se vuelve al principio del registro precedente. {\tt IOSTAT, ERR} tienen el mismo signifiado que en {\tt READ}. {\bf Sirve para releer registros y para remplazar registros escritos.}

\subsubsection{Sentencia {\tt REWIND}}
Sitaxis:
\begin{lstlisting}[language=Fortran]
	BACKSPACE ([UNIT=]u,  [FMT=]fmt [,IOSTAT=ios] [,ERR=e1] [,END=e2])
\end{lstlisting}
Posiciona el fichero conectado a la unidad {\tt u} al principio de su primer registro. {\tt IOSTAT, ERR} tienen el mismo signifiado que en {\tt READ}. 

\subsubsection{Sentencia {\tt ENDFILE}}
La sintaxis elemental

\begin{lstlisting}[language=Fortran]
	ENDFILE ([UNIT=]u,  [FMT=]fmt [,IOSTAT=ios] [,ERR=e1] [,END=e2])
\end{lstlisting}
\subsection{Ficheros internos}
Escribe un registro de fin de fichero conectado a la unidad {\tt u}. Se posiciona después del registro de fin de fichero. {\tt IOSTAT, ERR} tienen el mismo signifiado que en {\tt READ}. Se escribe automáticamente un registro de fin de fichero si:

\begin{itemize}
	\item Se ejecuta \texttt{BACKSPACE} o  \texttt{REWIND} después de {\tt WRITE} en la unidad {\tt u}.
	\item Se cierra el fichero con {\tt CLOSE}.
	\item Se ejecuta {\tt OPEN} con la unidad {\tt u}.
	\item El programa termina normalmente.
\end{itemize}

\section{Elaboración de programas}

Es importante cuidar la elaboración del programa fuente y procurar satisfacer varios objetivos, entre otros: que sea claro y legible tanto para el autor del programa como para otros potenciales usuarios, que sea fácil de detectar errores, que sea eficiente en tiempo, precisión o memoria, que permita introducir cambios con facilidad, etc.

\subsection{Estilo de programación}

Algunos detalles que favorecen el estilo de programación son:

\begin{itemize}
	\item Amplio uso de comentarios: incluir una breve descripción de algoritmos o procedimientos al principio de cada unidad de programa, en secciones de código diferencias, en límties de arrays, en sentencias que deberían cambiarse para ejecución con otros datos, etc.
	\item Descripción del significado de cada variable.
	\item Declaración organizada de variables (alfabética, por tipos, agrupada por similaridades, etc.).
	\item Líneas en blanco de separación entre secciones de código (blucles, bloques, {\tt IF},...) y entre subprogramas.
	\item Desplazamiento (``Identación'') de las sentencais de estructuras (blucles, bloques, {\tt IF, CASE,...}) unos espacios (6 espacios).

\end{itemize}
\subsection{Depuración de errores}

Los errores que pueden cometerse en la elaboración de un programa Fortran son de clase muy diversa: sintaxis, diseño de programa, programación, algorítmicos, instalación del software, errores de tamaño de memoria, etc. Una vez realizada una correcta instalción del software, los otros errores son imputables al usuario ó a limitaciones del software o hardware. La ley de MURPHY no falla cuando se aplica en programación. Algunos detalles que favorecen la detección y correción de errores son:

\begin{itemize}
	\item Una redaccion clara con suficientes comentarios.
	\item Evitar estructuras de control, formatos y expresiones complicados.
	\item Si un programa es muy largo, conviene partirlo en subprogramas. Es difícil corregir un subprograma de más de unasd 300 líneas ejecutables.
	\item En primeras versiones de un programa, conviene incluir sentencias de escritura (a pantalla ó fichero) después de secciones diferenciadas de código con objeto de aislar posibles errores o comprobar el buen funcionamiento de partes de código.
\end{itemize}
 

\subsection{Optimización de programas}

Algunos detalles que afectan a la eficiencia de un programa son:

\begin{itemize}
	\item Uso de la opción de compilación para optimizar la velocidad de ejecución.
	\item Potenciación {\tt a**b}:
	      \begin{itemize}
		      \item Si {\tt b }es entero, tenemos que hasta {\tt b}$>$5 la exponenciación se obtiene con {\it multiplicaciones}.
		      \item Si {\tt b }es real, se calcula como {\tt EXP(b*LOG(a))}.
	      \end{itemize}
	\item La raíz cuadrada es una operación rápida.
	\item Siempre que se pueda conviene ahorrar operaciones y simplificar fórmulas aunque las expresiones pueden ser numéricamente distintas.
	\item Si no hay peligro conviene reutilizar variables, vectores, y matrices. Si los elementos de un vector o matriz son conocidos, se pueden prescidir de ellos. El acceso a elementos de arrays consume tiempo.
\end{itemize}