\chapter{Introducción a Fortran}

\section{Estructura del programa}

\subsection{Formato código fuente}

El formato de condigo guente puede ser libre o fijo, y no deben mezclarse ambos en un fichero de código. El código fijo se considera obsoleto en Fortran95. En cualquier caso existen ciertas normas básicas y típicas de fortran, ataño obligatorias, que todavía se mantienen, por lo que es importante mencionarlas. Estas son:

\begin{itemize}
	\item Las sentencias de un programa se escribem en diferentes líneas.
	\item La posición de los caracterres dentro de las líneas es significativa.
	\item Columnas:
	      \begin{itemize}
		      \item 1-5. Número de etiqueta (de 1 a 5 dígitos, se usan números usualmente).
		      \item 6. Carácter de continuación de línea.
		      \item Resto. Sentencia.
	      \end{itemize}
	\item Comentarios:
	      \begin{itemize}
		      \item Las líneas en blanco se ignoran. Hacen más legible el programa.
		      \item Si el primer carácter de una línea es *, c o C la línea es de comentario.
		      \item Si aparece el carácter ! en una línea (salvo en la columna 6) lo que sigue es un comentario.
	      \end{itemize}
	\item Una línea puede contener varias sentencias separadas por punto y coma (;), el cual no puede estar en la columna 6. Sólo la primera de estas sentencias podría llevar etiqueta.
	\item Los espacios en blanco son significativos: {\tt IMPLICIT NONE, DO WHILE} (obsoleto), {\tt CASE DEFAULT}. Son opcionales en:
	      \begin{itemize}
		      \item Palabras clave dobles qeu comienzan por {\tt END} o {\tt ELSE}.
		      \item {\tt DOUBLE PRECISION, GO TO, IN OUT, SELECT CASE.}
	      \end{itemize}
	\item  El indicador de continuación de una línea es el carácter \&.
\end{itemize}

\subsection{Tipos de datos}

Fortran tiene los siguientes tipos de datos:

\begin{itemize}
	\item Enteros ({\tt INTEGER})
	\item Reales ({\tt REAL, DOUBLE PRECISION})
	\item Complejos ({\tt COMPLEX})
	\item Lógicos ({\tt LOGICAL})
	\item Caracteres ({\tt CHARACTER, CHARACTER(LEN=n), CHARACTER*n})
\end{itemize}

\subsubsection{Parámetros. Variables. Declaración. Asignación.}

\begin{itemize}
	\item Un parámetro tiene un valor que no se puede cambiar (PARAMETER).
	\item Una variable puede cambiar su valor cuantas veces sea necesario.
	\item Por defecto, todas las variables que empiecen por \texttt{i,j,k,l,m} o \texttt{n} son entreas y las demas reales. Es muy recomendable declarar las variables que se utilicen (la sentencia {\tt IMPLICIT NONE} obliga a declarar todas las variables).
\end{itemize}

\subsubsection{Arrays, subíndices, substrings}

\begin{itemize}
	\item Un array se define mediante su nombre y dimensiones (cantidad y límites).
	\item Por defecto el primer índice es 1. En otro caso hay que indicar el rango {\tt i1:i2}.
	\item Los elementos del array se acceden por sus índices entre paréntesis.
\end{itemize}



\subsection{Operadores y expresiones}

\subsubsection{Aritméticas}

\begin{itemize}
	\item Los operadores aritméticos son {\tt +, -, *, /, **}.
	\item El orden de prioridades es el mismo que en el álgebra.
	\item No puede ver operadores seguidos (incorrecto {\tt a*-b}, correcto {\tt a*(-b)}).
\end{itemize}

\subsubsection{Relacion y expresiones lógicas}

\begin{itemize}
	\item Los operadores de expresiones son:
	      \begin{table}[h!] \centering
		      \begin{tabular}{|c|c|c|c|c|c|}
			      \hline
			      {\tt .EQ.} & {\tt .NE.} & {\tt .LT.} & {\tt .LE.} & {\tt .GT.} & {\tt .GE.} \\ \hline
			      $==$       & $/=$       & $<$        & $<=$       & $>$        & $>=$       \\    \hline
		      \end{tabular}
	      \end{table}

	\item Se pueden relacionar expresiones aritméticas con expresiones lógicas y expresiones de caracteres.
	\item Es recomendable utilizar paréntesis y/ó sustituir las expresiones complicadas por combinaciones de expresiones más simples.
	\item Los operadores lógicos son:
	      \begin{table}[h!] \centering
		      \begin{tabular}{|c|c|c|c|c|c|}
			      \hline  Operador & {\tt .NOT.} & {\tt .AND.} & {\tt .OR.} & {\tt .EQV.} & {\tt .NEQV.} \\ \hline Prioridad
			                       & 1           & 2           & 3          & 4           & 4            \\    \hline
		      \end{tabular}
	      \end{table}
\end{itemize}

\subsection{Entrada y salida estándar sin formato}


Los dispositivos estándar (por defecto) de entrada y salida de datos son el teclado y la pantalla:

\begin{itemize}
	\item Lectura de datos de teclado. Son equivalentes las siguientes sentencias:
	      \begin{itemize}
		      \item {\tt READ (*,*), listavar}
		      \item {\tt READ* , listavar}
	      \end{itemize}

	\item Escritura de datos en pantalla. Son equivalentes las siguientes sentencias:
	      \begin{itemize}
		      \item {\tt WRITE (*,*), listavar}
		      \item {\tt PRINT* , listavar}
	      \end{itemize}
\end{itemize}
Donde {\tt listavar} es una lista de variables o elementos de arrays separados por comas.

\subsection{Sentencias, {\tt PROGRAM, END}}

\begin{itemize}
	\item Un programa puede comenzar con la sentencia {\tt PROGRAM nombprog.}
	\item Un programa debe terminar con la sentencia {\tt END  [PROGRAM [nombreprog]]}.
\end{itemize}
Donde \texttt{ nombreprog} es el nombre del programa, que debe empezar por una letra y admite hasta 31 letras, dígitos y guiones underscore.

\section{Setencias de control}

Las sentencias de control sirven para alterar la ejecución de las sentencias de un programa.



\subsection{Setencia {\tt CONTINUE}}

La sentencia \texttt{CONTINUE} es ejecutable, pero no realiza acción alguna. Es útil para rupturas de secuencia y manejo de errores en lectura de datos. Su número de etiqueta puede ser referenciado en sentencia \texttt{DO}.

\subsection{Setencia {\tt STOP}}

La sentencia {\tt STOP} detiene la ejecución del programa. Tiene dos variantes {\tt STOP [`mensaje'], STOP[n]}. Si está presente el literal {\tt `mensaje'} ó el número {\tt  n} (que ha de tener de 1 a 5 dígitos), se visualizan en pantalla. Puede llevar etiqueta y formar parte de una sentencia {\tt IF}, y sirve principalmente para detener la ejecución a causa de un error y con el literal `{\tt mensaje}' ó el número {\tt n}.

\subsection{Setencia {\tt GOTO}}

La sintaxis {\tt GOTO e} transfiere el control a la secuencia ejecutable con etiqueta {\tt e} que se encuentra en la misma unidad de programa que la setencia {\tt GOTO}. No se puede entrar en bloques {\tt DO, IF, CASE} desde fuera de ellos con las sentencias {\tt GOTO}. \\

Es una sentencia cuyo uso genera mucha polémica. Un programa con gran cantidad de {\tt GOTO} es difíciol de comprender, sobre todo si hay muchas transferencias a sentencias anteriores. Con una adecuada programación pueden sustituirse, con facilidad, la mayoría de las sentencias {\tt GOTO} por otras estructuras de control. Sin embargo, hay ocasiones cuya sustitución complica enormemente la lógica del programa. Es especialmente útil para tratar condiciones de error o de terminación de un bloque. Conviene NO abusar de esta sentencia. \\

Si la sentencia siguiente a la sentencia {\tt GOTO} no lleva etiqueta no se ejecutará nunca (código muerto). Es un síntoma de error de programación.

\subsection{Setencia {\tt IF}}

La sintaxis es {\tt IF (expres) sentec}. La expresión {\tt expres} debe ser escalar lógica, si es verdadera se ejecuta {\tt sentenc}; si es falsa no se ejecuta {\tt sentenc} y se continua a la sentencia siguiente. La sentencia {\tt sentenc} debe ser ejecutable, no puede ser la sentencia {\tt END} ni la sentencia inicial o final de bloques {\tt DO, IF, SELECT, CASE}. \\

Esta sentencia se suele utilizar para realizar, en función de la condición, una única asignación, una sencilla escritura de datos, una parada del programa, una ramificación del flujo del programa.

\subsection{Bloque {\tt IF-THEN-ENDIF}}

La sitáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] IF (expres) THEN 
		bloq....
	ENDIF[nomb]
\end{lstlisting}

La expresión \texttt{expres} debe ser escalar lógica. Si es verdadera se ejectutan las sentencias del bloque \texttt{bloq} entre \texttt{THEN} y \texttt{ENDIF}. Si es falsa se continúa en la siguiente sentencia a \texttt{ENDIF}. Si lleva nombre (opcional), debe ser un nombre válido en Fortran distinto de otras nombres en la unidad de alcance en la que está el bloque \texttt{IF}.


\subsection{Bloque {\tt IF-THEN-ELSE-ENDIF}}
La sitáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] IF (expres) THEN 
		bloq1 
	ELSE [nomb] 
		bloq2 
	EDNDIF[nomb] 
\end{lstlisting}

La expresión \texttt{expres} debe ser escalar lógica. Si es verdadera se ejectutan las sentencias del bloque \texttt{bloq} entre \texttt{THEN} y \texttt{ENDIF}. Si es falsa se continúa en la siguiente sentencia a \texttt{ENDIF}. Si lleva nombre (opcional), debe ser un nombre válido en Fortran distinto de otras nombres en la unidad de alcance en la que está el bloque \texttt{IF}.


\subsection{Bloque {\tt ELSE-IF}}

La sitáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] IF (expres) THEN 
		bloq1 
	[ElSEIF (expres_i) THEN [nomb] b
		bloq_i]...
	[ELSE [nomb]
		bloq2]
	EDNDIF[nomb] 
\end{lstlisting}

Cada expresión {\tt expres, expres\_i} debe ser escalar lógica. Si {\tt expres} es verdadera se ejecutan las sentencias del bloque {\tt bloq1} entre {\tt THEN} y el primer {\tt ELSEIF} y se pasa a la siguiente sentencia a \texttt{ENDIF}. Si \texttt{expres\_i} es falsa se inspeccionan en orden las expresioens \texttt{expres\_i} hasta que una sea verdadera, en cuyo caso se ejecutan las sentencias del bloque {\tt bloq\_i} correspondiente y el control pasa a la siguiente sentencia \texttt{ENDIF}. Si la expresión {\tt expres} y todas las expresiones {\tt expres\_i} son falsas, se ejecutan las sentencias del bloque \texttt{bloq2} entre {\tt ELSE} y {\tt ENDIF}. \\

Las sentencias {\tt ELSEIF} y {\tt ELSE} pueden llevar nombre sólo si sus sentencias {\tt IF} y {\tt ENDIF} llevan y, en estec aso debe ser el mismo. No se puede entrar en un bloque {\tt IF, THEN, ELSEIF} ni {\tt ELSE} desde fuera de él con sentencias {\tt GOTO}, aunque si se peude salir en cualquier lugar con la misma. En el siguiente código podemos ver un ejemplo del uso de este bloque para resolver una función definida a trozos.

\begin{lstlisting}[language=Fortran]
	REAL x, f
	PRINT*,'valor de x =' ; READ*, x
	IF (0<=x .AND. x<=1) THEN
		f = 3*x**2 - 1
	ELSEIF (5<=x .AND. x<=10) THEN
		f = 6*x + 4
	ELSEIF (20<=x .AND. x<=40) THEN
		f = -7*x + 1
	ELSE
		f = 0
	ENDIF
	PRINT*, ' x = ', x, ' f = ', f
	END
\end{lstlisting}


\subsection{Selector {\tt SELECT CASE}}

La sintaxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[nomb:] SELECT CASE (expres) 
	CASE (selector) [nomb]
		bloq... 
	CASE DEFAULT [nomb]
		bloq0... 
	ENDSELECT [nomb]
\end{lstlisting}

La expresión {\tt expres} debe ser escalar de tipo entera, lógica ({\it poco interesante}) ó carácter y los valores dados deben ser del mismo tipo (en el caso carácter las longitudes pueden ser diferentes pero no la clase, en los casos entero o lógico pueden ser diferentes). Si el valor {\tt expres} pertenece a un selector se ejecuta su bloque de sentencias y se continúa en la siguiente sentencia a  {\tt END SELECT}. Si no pertenece a ningún selector se ejecutan las sentencias del bloque \texttt{CASE DEFAULT}, si está presente y si no lo está se continúa en la siguiente sentencia a {\tt END SELECT}. \\

Si lleva nombre (opcional) debe ser un nombre válido en Fortran y distinto de otros nombres en la unidad de alcance en qeu se encuentra el bloque {\tt SELECT}. Las sentencias \texttt{CASE} y \texttt{CASE DEFAULT} pueden llevar nombre sólo si las sentencias {\tt SELECT CASE} y {\tt CASE} correspondientes lo llevan y, en este caso, debe ser el mismo. Los valores de los selectores han de ser disjuntos. Se separan por comas y puede especificarse un rango de valores, también disjuntos en cada selector. No se puede entrar en un bloque {\tt SELECT} ó {\tt CASE} desde fuera de él con sentencias {\tt GOTO}. Se puede salir en cualquier lugar con sentencias {\tt GOTO}. Los bloques {\tt SELECT CASE} pueden anidarse. \\

La diferencia principal entre los bloques {\tt IF} y {\tt CASE} es que en {\tt CASE} sólo se evalúa una expresión cuyo valor deb estar en un conjunto predefinido de valores, mientras que en {\tt IF} se pueden evaluar varias expresiones de naturaleza distinta. Veamos un ejemplo para entender mejor el problema:

\begin{lstlisting}[language=Fortran]
	CHARACTER car! equivale a CHARACTER(LEN=1) car
	INTEGER indice
	PRINT*, ' Introducir un caracter'
	READ*, car
	SELECT CASE (car)
	CASE ('a', 'e', 'i', 'o', 'u')
		PRINT*, ' Vocal minuscula : ', car
	CASE ('A', 'E', 'I', 'O', 'U')
		PRINT*, ' Vocal MAYUSCULA : ', car
	CASE ('b':'d', 'f':'h', 'j':'n', 'p':'t', 'v':'z')
		PRINT*, ' Consonante minuscula : ', car
	CASE ('B':'D', 'F':'H', 'J':'N', 'P':'T', 'V':'Z')
		PRINT*, ' Consonante MAYUSCULA : ', car
	CASE ('0':'9')
		PRINT*, ' Cifra del 0 al 9 : ', car
	CASE DEFAULT
		PRINT*, ' El caracter no es ni letra ni numero : ', car
	ENDSELECT

	PRINT*, ' Introducir un numero'
	READ*, indice

	SELECT CASE (indice)
	CASE (2, 3, 5, 7, 11, 13, 17, 19)
		PRINT*, ' Numero primo menor que 20 : ', indice
	CASE (20:29, 40:49, 60:69, 80:89)
		PRINT*, ' Numero menor que 100 con decena par : ', indice
	CASE (100:999)
		PRINT*, ' Numero de 3 cifras : ', indice
	CASE DEFAULT
		PRINT*, ' Resto de casos : ', indice
	ENDSELECT
	END
	
\end{lstlisting}

\subsection{Interacciones {\tt DO}}

La sintaxis es:

\begin{lstlisting}[language=Fortran]
	[nomb:] Do [,] var = expres1, expres2, expres3 
		bloq
	ENDDO [nomb]
\end{lstlisting}

La variable {\tt var} y las expresiones {\tt expres1, expres2, expres3} (esta última opcional) deben ser escalares enteras. La variable {\tt var} toma el valor inicial de {\tt expres1}, se ejecutan las sentencias {\tt bloq} del bloque {\tt DO}; {\tt var} se incrementa en {\tt expres3}, se ejecutan las sentencias del bloque {\tt DO}, y así sucesivamente hasta que {\tt var$>$expres2} (si {\tt expres3$>$0} ó  {\tt var$<$expres2} (si {\tt expres3$<$0}) en cuyo caso se continúa en la siguiente sentencia a {\tt ENDDO}. \\

El número de interacciones que se realizan en el bloque {\tt Do} (si no se sale de él antes de terminar) es: {\tt MAX\{ (expres2-expres1+expres3)/expres3,0 \}}. Cuando \{ {\tt expres1$>$expres2} y {\tt expres3$>$0} \}  ó \{ {\tt expres1$<$expres2} y {\tt expres3$<$0} \}  no se ejecuta el bloque {\tt DO}. Si {\tt expres1} y/ó {\tt expres2} y/ó {\tt expres3} son expresiones que incluyen variables, el valor de éstas puede cambiarse dentro del bloque  {\tt DO} y esto no altera el número de interaciones (calculado con sus valores iniciales). 

\subsection{{\tt DO} ilimitado, {\tt EXIT} y {\tt CYCLE}}

El {\tt DO} ilimitado tiene la siguiente sintaxis:

\begin{lstlisting}[language=Fortran]
	[nomb:] Do 
		bloq
	ENDDO [nomb]
\end{lstlisting}
Y la acción del mismo es que se repitan las sentencias {\tt bloq} indefinidamente, pudiendo salir del mismo con las sentencias {\tt EXIT} y {\tt GOTO}. \\


La sentencia {\tt EXIT[nomb]} dentro de un bloque {\tt Do} transfiere el control a la primera sentencia ejecutable después del {\tt ENDDO} a que se refiere, sino se indica el nombre {\tt nomb}, transfiere el control al {\tt ENDDO} del bloque más interior en el que está contenida. \\ 


La sentencia {\tt CYCLE[nomb]} dentro de un bloque {\tt Do} transfiere el control a la sentencia {\tt ENDDO} a que se refiere, sino se indica el nombre {\tt nomb}, transfiere el control al {\tt ENDDO} del bloque más interior en el que está contenida. 


\section{Utilidades de programa. Procedimientos.}

\subsection{Programa principal}

Un programa completo debe tener exactamente un programa principal. La forma es la siguiente:

\begin{lstlisting}[language=Fortran]
	PROGRAM [nombreprog]
		[sentencias de especificacion]
		[sentencias ejecutables]
	CONTAINS
		[subprogramas internos	]
	END PROGRAM [nombreprog]	
\end{lstlisting}

\subsection{Subprogramas externos}

Son llamados desde el programa principal o desde otros subprogramas. Pueden ser funciones o subrutinas. Ambas pueden ser recursivas, esto es, llamarse a sí mismas. No obstante esto es muy complejo, y su uso implica peor eficacia computacional. 

\subsection{Uso no recursivo de subprogramas {\tt FUNCTION}}

La sitaxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	[tipo] FUNCTION nombfun ([argumentos ficticios])
		[sentencias de especificacion]
		[sentencias ejecutables]
	END [FUNCTION [nombreprog]]
\end{lstlisting}

Con esto estaríamos definiendo el subprograma {\tt FUNCTION nombfun}, invocándose con {\tt nombfun([argumentos actuales])}, y substituyendose los argumentos actuales en los ficticios y se evalúa la función. El valor asignado a {\tt nombfun} es el valor devuelto a la función. Téngase en cuenta que:

\begin{itemize}
	\item El término {\tt tipo} es opcional. Si se omite se toma el tipo por defecto o el que haya sido establecido por sentencias {\tt IMPLICIT}. 
	\item La llamada puede formar parte de una expresión o sentencia más larga. Un subprograma {\tt FUNCTION} puede contener cualquier sentencia excepto: {\tt PROGRAM, FUNCTION, SUBROUTINE} y {\tt BLOCK DATA}.
	\item La última sentencia tiene que ser {\tt END}. 
	\item Las variables y etiquetas en un subprograma {\tt FUNCTION} son locales, esto es, independientes del programa principal y las de otros subprogramas. 
	\item Los argumentos actuales deben coincidir en cantidad, orden, tipo y longitud con los argumentos ficticios. Puede no haber argumentos.
	\item Los argumentos actuales pueden modificarse: sin embargo, esta opción es especialmente desaconsejable. 
	\item Una función no recursiva no puede llamarse a sí misma ni directa ni indirectamente, pero sí puede llamar a otros subprogramas.
\end{itemize}

\subsubsection{Sentencia {\tt RETURN} en Subprogramas {\tt FUNCTION}}

{\tt RETURN} termina la ejecución de la función y devuelve el control a la unidad de programa que llamó a la función. Si la función no tiene sentencias {\tt RETURN} su ejecución termina al llegar a la sentencia {\tt END}. Puede ser una setntencia con etiqueta, y puede formar parte de una sentencia {\tt IF}.

\subsection{Uso no recursivo de Subprogramas {\tt SUBROUTINE}}

La sintaxis escalar

\begin{lstlisting}[language=Fortran]
	SUBROUTINE nombsubr ([argumentos ficticios])
		[sentencias de especificacion]
		[sentencias ejecutables]
	END [SUBROUTINE [nombresubr]]
\end{lstlisting}

La llamada a la subrutina se realiza mediante la sentencia {\tt CALL nombsubr [(argumentos actuales)]}, substituyendose los argumentos actuales en los ficticios. Las normas son las siguientes:

\begin{itemize}
	\item La llamada puede formar parte de una expresión o sentencia más larga. Un subprograma {\tt FUNCTION} puede contener cualquier sentencia excepto: {\tt PROGRAM, FUNCTION, SUBROUTINE} y {\tt BLOCK DATA}.
	\item La última sentencia tiene que ser {\tt END}. 
	\item Las variables y etiquetas en un subprograma {\tt FUNCTION} son locales, esto es, independientes del programa principal y las de otros subprogramas. 
	\item Los argumentos actuales deben coincidir en cantidad, orden, tipo y longitud con los argumentos ficticios. Puede no haber argumentos.
	\item Una función no recursiva no puede llamarse a sí misma ni directa ni indirectamente, pero sí puede llamar a otros subprogramas.
\end{itemize}

\subsubsection{Sentencia {\tt RETURN} en Subprogramas {\tt SUBROUTINE}}

{\tt RETURN} termina la ejecución de la subrutina y devuelve el control a la unidad de programa que llamó a la función. Si la subrutina no tiene sentencias {\tt RETURN} su ejecución termina al llegar a la sentencia {\tt END}. Puede ser una setntencia con etiqueta, y puede formar parte de una sentencia {\tt IF}.

\subsection{Argumentos de subprogramsas externos}

Los argumentos de un subprograma {\tt FUNCTION} O {\tt SUBROUTINE} pueden ser de naturaleza muy diversa: constantes o variables escalares, arrays o elementos de arrays, nombres de otros subprogramas, etc. Es necesario suministrar al compilador la información adecuada para identificar correctamente la naturaleza del argumento. 

\subsubsection{Propósito de los argumentos}

Los argumentos ficticios pueden tener una declaración de propósito de entrada salida o entrada/salida. El propósito se declara con el atributo {\tt INTENT}. 

\begin{itemize}
	\item {\tt INTENT (IN)}: declara un argumento de entrada. No debe cambiarse su valor dentro del subprograma. 
	\item {\tt INTENT (OUT)}: declara un argumento de salida. El argumento actual debe ser una variable y se vuelve indefinida en entrada.
	\item {\tt INTENT (IN/OUT)}: declara un argumento de entrada o salida. El argumento actual debe ser una variable.
\end{itemize}

Es recomendable declarar el propósito de los argumentos ficticios, lo cual ayuda a la documentación del programa y a las verificaciones durante la compilación.



\subsection{Sentencia {\tt EXTERNAL}}

Se escribe como {\tt EXTERNAL lista}, e identifica los nombres de {\tt lista} como subprogramas (funciones o subrutinas) externos definidos por el usuario. Al ser una sentencia de especificación, debe preceder a las  ejecutables y a las declaraciones de funciones. Cuando un argumento de un subprograma es el nombre de otro subprogarama, se debe declarar {\tt EXTERNAl} en su unidad de llamada. Si una función intrínseca se declara {\tt EXTERNAL} pierde su definición intrínseca en la unidad de programa asociada y se usa el subprograma del usuario. 


\begin{lstlisting}[language=Fortran]
	EXTERNAL fun1, fun2, sin
	x=1.5; n=3
	CALL ameba (x, n, y1, fun1)		! y1 = x**(5-n) = 2.25
	CALL ameba (x, n, y2, fun2)	 	! y2 = 3*x*(5-n) = 9
	s = sin (y1, y2, 6.0, x)			! s = y2/y1 + 6/x = 8
	PRINT*, y1, y2, s
	END

	SUBROUTINE ameba (x, n, y, f)
		y = f(x, 5, n)
	END

	FUNCTION fun1 (x, i, j)
		fun1 = x**(i-j)
	END

	FUNCTION fun2 (x, i, j)
		fun2 = 3*x*(i-j)
	END

	FUNCTION sin (a, b, c, d)
		sin = b/a + c/d
	END
\end{lstlisting}

\subsection{Sentencia INTRINSIC}

La sintaxis {\tt INTRINSIC lista} declara los nombres de {\tt lista} como funciones intrínsecas. Las normas son
\begin{itemize}
	\item Los nombres de la {\tt lista} deben ser funciones intrínsecas.
	\item Si un argumento de un subprograma es una función intrínseca se debe declarar {\tt INTRINSIC} en la unidad de llamada. 
	\item Si un nombre está en una sentencia {\tt INTRINSIC} no puede estar en una sentencia {\tt EXTERNAL}.
\end{itemize}

\begin{lstlisting}[language=Fortran]
	INTRINSIC sin, cos, exp
	a=3.141592; b=-a
	r = fun (sin, cos, exp, a, b, 4)
	PRINT*, r
	END

	FUNCTION fun (f1, f2, f3, a, b, n) ! fun = (sin(a)+cos(b)+
	fun = (f1(a) + f2(b) + f3(a+b)) ** n ! exp(a+b))**n	
	END
\end{lstlisting}

\subsection{Subprogramas internos}

Son subprogramas contenidos en el programa principal, en un subprograma externo o en un módulo. Su uso es adecuado, a efectos de organización, para subprogramas cortos (del orden de unas 20 líneas), que sólo se necesitan en un único programa, subprograma o módulo.  La sintáxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	CONTAINS
	subprogramas internos
\end{lstlisting}
Y las normas son:

\begin{itemize}
	\item Los subprogramas internos deben aparecer entre la sentencia {\tt CONTAINS} y la sentencia {\tt END} de la unidad de programa a la que pertenezcan. 
	\item Un subprograma interno no puede contener a otro subprograma interno.
	\item Un subprograma interno sólo puede llamarse desde su host.
	\item Un host conoce todo acrca de la interface con sus subprogramas internos, por tanto no hace falta declarar el tipo en el host para una función interna.
	\item Un subprograma interno tiene acceso a las variables del host.
	\item El host no tiene acceso a las variables locales de los subprogramas internos.
	\item La sentencia {\tt IMPLICIT NONE} en un host afecta al host y también a sus subprogramas internos. 
	\item Las etiquetas son locales. Si una sentencia tiene etiqueta, ésta debe estar en la misma unidad de alcance que la sentencia que la referencia.
\end{itemize}

\begin{lstlisting}[language=Fortran]
	PROGRAM interno
		CALL coefbinomial ! invoca una subrutina interna

	CONTAINS

		SUBROUTINE coefbinomial
			INTEGER n, k
			CALL leer(n) ! invoca una subrutina interna
			DO k = 0, n
				PRINT*, k, nsobrek(n,k) ! invoca una funcion interna
			ENDDO
		ENDSUBROUTINE coefbinomial

		SUBROUTINE leer(n)
			INTEGER n
			PRINT*, ' Introducir el valor de n'
			READ*, n
		ENDSUBROUTINE leer

		FUNCTION nsobrek(n,k)
			INTEGER nsobrek, n, k
			nsobrek = fact(n) / (fact(k)*fact(n-k)) ! invoca una funcion
		ENDFUNCTION nsobrek ! interna 3 veces

		FUNCTION fact(m)
			REAL fact
			INTEGER m, i
			fact = 1
			DO i = 2, m
				fact = i*fact
		ENDDO
		ENDFUNCTION fact

	ENDPROGRAM interno
\end{lstlisting}

Su principal utilidad es organizar mejor el código y permitir un mayor control sobre el ámbito de las variables, ya que los subprogramas internos solo pueden ser llamados desde el subprograma en el que están definidos. Las principales ventajas de los subprogramas internos son:

\begin{itemize}

	\item Encapsulamiento: Permiten encapsular la lógica auxiliar o funciones específicas que solo tienen sentido dentro del contexto del subprograma principal. Esto ayuda a mantener el código más legible y modular.

	\item Ámbito de variables: Las variables locales del subprograma externo pueden ser utilizadas directamente dentro del subprograma interno, lo que evita la necesidad de pasarlas como argumentos. Esto simplifica el manejo de variables cuando son comunes a ambos subprogramas.

	\item Modularidad: Facilita la descomposición de tareas complejas en tareas más simples, dividiendo la lógica en partes más manejables, lo que mejora la mantenibilidad del código.

\end{itemize}


\subsection{Módulos}

Un módulo permite empaquetar definiciones de datos y compartir datos entre diferentes unidades de programas que pueden incluso compilarse por separado. Sirve, especialmente, para crear grandes librerías de software. En su uso sencillo:

\begin{itemize}
	\item Ofrece posibilidades similares a {\tt INCLUDE}.
	\item Permite compartir datos en ejecución.
	\item Sirve para inicializar variables.
\end{itemize}

La sitátxis es la siguiente:

\begin{lstlisting}[language=Fortran]
	MODULE nombmod
		[sentencias de especificacion]
	ENDMODULE nombmod
\end{lstlisting}
Y las normas

\begin{itemize}
	\item Se puede acceder a un módulo desde el programa principal, un subprograma u otro módulo. Se accede a las especificaciones y variables del módulo con los valores asignados (si los tienen). Las variables y datos de un módulo con los valores asignados si los tienen. Las variables y datos de un módulo tienen, por defecto, alcance {\bf global}, en todas las unidades desde las que se acceden con {\tt USE}.
	\item Desde un módulo se tiene acceso a las otras entidades del módulo incluyendo subprogramas. 
	\item Puede contener sentencias {\tt USE} para acceder a otros módulos.
	\item No debe acceder a sí mismo directamente o indirectamente a través de {\tt USE}.
	\item El módulo debe compilarse antes que el programa que lo usa. En la sentencia compilación se crea un fichero {\tt *.mod} que es el que lee la sentencia {\tt USE}. Se recomienda que un módulo solo acceda a módulos anteriores a él.
\end{itemize}


\subsection{Orden de las sentencias}

Las diferentes sentencias que puede contener un programa de Fortran deben escribirse en el orden siguiente (tabla \ref{Tab:01-01}).

\begin{table}[h!] \centering
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{{\tt PROGRAM, FUNCTION, SUBROUTINE, MODULE}} \\ \hline
		\multicolumn{3}{|c|}{\texttt{USE}} \\ \hline
		\multirow{7}{*}{\texttt{FORMAT}} & \multicolumn{2}{l|}{\texttt{IMPLICIT NONE}}\\  \cline{2-3}
		 & \texttt{PARAMETER} & \texttt{IMPLICIT} \\  \cline{2-3}
		 & \multirow{4}{*}{\texttt{PARAMETER, DATA}} & Tipos derivados \\
		 &  & Bloques \texttt{INTERFACE} \\
		 &  & Declaración de tipos\\ 
		 &  & Sentencias de especificación \\  \cline{2-3}
		 &  \multicolumn{2}{l|}{Sentencias ejecutables}  \\ \hline
		\multicolumn{3}{|c|}{\texttt{CONTAINS}} \\ \hline
		\multicolumn{3}{|c|}{Subprogramas inteernos o subprogramas modulo} \\ \hline
		\multicolumn{3}{|c|}{\texttt{END}} \\ \hline
	\end{tabular}
	\caption{orden de las sentencias.}
	\label{Tab:01-01}
\end{table}

\section{Procedimientos intrínsecos}

Los procedimientos intrínsecos son funciones y subrutinas que forman parte del lenguaje Fortran estándar, suministradas con el compilador. En fortar 95 hay 109 funciones y 6 subrutinas que pueden clasificarse en cuatro categorías de procedimientos intrínsecos:

\begin{itemize}
	\item \textbf{Procedimientos elementales}: sus argumentos son escalares o arrayas. Si una función elemental se aplica a un array la función se aplica a cada elemento del array.
	\item \textbf{Funciones de interrogación}: devuelven propiedades de sus argumentos que no dependen de sus valores.
	\item \textbf{Funciones transformacionales}: suelen tener argumentos de arrays y resultados de arrays cuyos elementos dependen de muchos elementos del argumento.
	\item \textbf{Subrutinas no elementales}
\end{itemize}

Cada función devuelve un valor entero, real, complejo, lógico... de modo que tendremos que abreviar de algún modo el tipo de valor devuelto. En este caso usaremos que:


\begin{table}[h!] \centering
	\begin{tabular}{|c|c|}
		\hline 
		I & Entero \\ 
		\hline 
		R & Real \\
		\hline 
		N & Numerico  \\
		\hline 
		L & Logico \\
		\hline 
		CH & Carácter\\
		\hline 
	\end{tabular}
	\caption{tipo de variable.}
	\label{Tab:01-02}
\end{table}
\newpage

\subsection{Funciones elementales que convierten tipos}

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l} 
	Nombre & Definición &  Tipo argumentos & Tipo función \\ \hline
	ABS(x) & Valor absoluto & I & I \\
	ABS(x) & Valor absoluto & R & R  \\
	ABS(z) & Módulo complejo & C & R \\
	AIMAG(z) & Parte imaginaria & C & R \\
	AINT(x) & Quita decimales &  R & R \\
	ANINT(x) & Redondeo & R & R \\
	CEILING(x) & Redondeo  (por arriba) &  R & I \\
	CMPLX(x[,y]) & Pasa a complejo & N  & C \\
	FLOOR(x) & Redondeo (por abajo) & R  & I \\
	INT(x) & Pasa a entero & N & I \\
	NINT(x) & Redondeo entero  & R  & I \\
	REAL(x) & Pasa a real & N & R \\
	\end{tabular}
	\caption{funciones elementales que pueden convertir tipos.}
	\label{Tab:01-03}
\end{table}

\subsection{Funciones elementales que no convierten tipos}


El resultado de las funciones elementales \ref{Tab:01-03} es del tipo de su primer argumento.

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición &  Tipo argumentos & Tipo función \\ \hline
		CONJG(z) & Conjugado complejo & C & C \\
		DIM(x,y) & Diferencia positiva & (I,I)  ó (R,R) & I ó R \\
		MAX(x1,x2,[,x3,...]) & Máximo & (I,I,…) ó (R,R,…)  & I ó R \\
		MIN(x1,x2,[,x3,...]) & Mínimo & (I,I,…) ó (R,R,…) & I ó R \\
		MOD(x,y) & Resto de x módulo y  & (I,I) ó (R,R) & I ó R \\
		MODULO(x,y)  & x módulo y & (I,I) ó (R,R) & I ó R \\ 
		SIGN(x,y) & Transferencia de signo & (I,I) ó (R,R) & I ó R \\
	\end{tabular}
	\caption{funciones elementales que no pueden convertir tipos.}
	\label{Tab:01-03}
\end{table}

\subsection{Funciones matemáticas elementales}

El resultado de las funciones elementales \ref{Tab:01-04} es del tipo de su primer argumento.

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición & Tipo argumentos & Tipo función \\ \hline
		ACOS(x) & Arco Coseno & R / $|x|\leq $1 & R en [0,$\pi$]  \\
		ASIN(x) & Arco Seno & R /  $|x|\leq $1 & R en [$-\pi/2$,$\pi/2$]  \\
		ATAN(x) & Arco Tangente & R & R en  [$-\pi/2$,$\pi/2$] \\
		ATAN2(y,x) & Argumento número complejo & (R,R) & R en  ($-\pi$,$\pi$] \\
		COS(x) & Coseno & R ó C & R ó C \\
		COSH(x) & Coseno hiperbólico & R & R \\
		EXP(x) & Exponencial & R ó C & R ó C \\
		LOG(x) & Logaritmo neperiano & R ó C & R ó C \\
		LOG10(x) & Logaritmo decimal  & R x$>$0 & R \\ 
		SIN(x) & Seno &  R ó C & R ó C \\
		SINH(x) & Seno hiperbólico & R & R \\
		SQRT(x) & Raíz cuadrada & R ó C & R ó C \\
		TAN(x)  & Tangente & R & R \\ 
		TANH(x) & Tangente hiperbólica &  R & R \\
	\end{tabular}
	\caption{funciones matemáticas elementales.}
	\label{Tab:01-04}
\end{table}


\subsection{Operaciones con matrices y vectores}

La función {\tt DOT\_PRODUCT(x,y)} requiere que x e y tengan una dimensión y el mismo tamaño. Si $x$ es entero o real devuelve $\sum x_i y_i$; si $x$ es complejo devuelve $\sum \overline{x}_i y_i$. Véase tabla \ref{Tab:01-05}.  \\

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición  & Tipo argumentos & Tipo función \\ \hline
		DOT\_PRODUCT(x,y) & Producto escalar real & (I ó R, I ó R) & I ó R \\
		DOT\_PRODUCT(z,y) & Producto escalar complejo & (C,I ó R) & C \\
		MATMUL(a,b) & Producto matricial & (N,N) & N \\
		TRANSPOSE(a) & Matriz traspuesta & N & N 
	\end{tabular}
	\caption{}
	\label{Tab:01-05}
\end{table}

La función  {\tt MATMUL(a,b)} devuelve un array de dos dimensiones en función de la forma de los dos arrays según la tabla \ref{Tab:01-06}.


\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Operación & Forma de a & Forma de b & Forma de MATMUL(a,b) \\ \hline
		Matriz x Matriz & (n,m) & (m,k) & (n,k) \\
 		Vector x Matriz & (m) & (m,k) & (k) \\
		Matriz x Vector & (n,m) & (m) & (n) \\
	\end{tabular}
	\caption{}
	\label{Tab:01-06}
\end{table}

\begin{table}[h!] \centering
	\begin{tabular}{l|l|l|l}
		Nombre & Definición &  Tipo argumentos & Tipo función \\  \hline
		MAXVAL(x) & Máximo elemento & I ó R & I ó R \\
		MINVAL(x) & Mínimo elemento & I ó R & I ó R \\
		PRODUCT(x) & Producto de los elementos & I ó R & I ó R \\
		SUM(a) & Suma de los elementos & I ó R & I ó R
	\end{tabular}
	\caption{}
	\label{Tab:01-07}
\end{table}
\newpage

\subsection{Números aleatorios}

La sintaxis para llamar a números aleatorios es la siguiente {\tt CALL RANDOM\_NUMBER ([HARVEST=]aleat)}, donde {\tt aleat} es un argumento real (escalar o array), devolviendo números seudoaleatorios en {\tt aleat} en el rango [0,1). \\

El otro tipo de forma de obtener un número aleatorio es usar {\tt CALL RANDOM\_SEED ([SIZE],[PUT],[GET])}, donde los argumentos son:

\begin{itemize}
	\item {\tt SIZE}: variable escalar {\tt INTEGER}. Variable de salida que contiene el tamaño {\tt N} del array semilla.
	\item {\tt PUT}: array {\tt INTEGER} de dimensión ({\tt N}). Variable de entrada utilizada para establecer la semilla.
	\item {\tt GET}: array {\tt INTEGER} de dimensión ({\tt N}). Variable de salida que contiene el valor actual de la semilla.
\end{itemize}
Si no se especifica una semmilla se establece una semilla que depende del procesador. Veamos un ejemplo de donde usamos los números aleatorios y el tiempo de cálculo:

\begin{lstlisting}[language=Fortran]
	PROGRAM aleatorio 
	INTEGER t1(8), t2(8)
	INTEGER i, numrep, semilla(1)
	REAL x, sx, tdif
	CHARACTER(LEN=8) date1, date2
	CHARACTER(LEN=10) time1, time2
	CHARACTER(LEN=5) zona

	PRINT*, ' numero de repeticiones'
	READ*, numrep
	PRINT*, ' semilla inicial'
	READ*, semilla
	CALL RANDOM_SEED (PUT=semilla)

	CALL DATE_AND_TIME (VALUES=t1, DATE=date1, ZONE=zona, TIME=time1)
	DO i = 1, numrep
		CALL RANDOM_NUMBER (x)
		sx = SIN(x)
	ENDDO

	CALL DATE_AND_TIME (VALUES=t2, TIME=time2, DATE=date2)

	PRINT*, ' zona=', zona
	PRINT*, ' date1=', date1, ' date2=', date2
	PRINT*, ' time1=', time1, ' time2=', time2

	tdif = 0.001*(t2(8)-t1(8)) + (t2(7)-t1(7)) + 60.*(t2(6)-t1(6)) + &
		3600.*(t2(5)-t1(5))
	PRINT*, ' tdif =', tdif

	ENDPROGRAM aleatorio
\end{lstlisting}



\section{Entrada y salida de datos. Ficheros. Formatos.}


\subsection{Elementos y clases de ficheros}

Los conceptos fundamentales a considerar son: campos, registro y fichero. 

\begin{itemize}
	\item \textbf{Campo:} unidad de información que consta de varios caracteres que se tratan en conjunto.
	\item \textbf{Registro:} conjuto de campos, no necesariamente del mismo tipo.
	\item \textbf{Fichero:} conjunto de registros, no necesariamente con igual estructura.
\end{itemize}
Como ejemplo un fichero de personas podría contener un registro por cada persona y los campos podrían ser: nombre, DNI, dirección, edad, teléfono\dots En algunos casos, por ejemplo en las bases de datos, los registros de un fichero tienen la misma estrucutra, esto es, el mismo número y forma de los campos. Los tipos de {\bf acceso} a un fichero en Fortran son secuencial o directo:

\begin{itemize}
	\item \textbf{Secuencial:} para acceder a un registro hay que recorrer todo el fichero desde el principio hasta llegar a él.
	\item \textbf{Directo:} conociendo el número de orden de un registro en el dichero se puede acceder a él sin tener que recorrer los registros anteriores.
\end{itemize}

Los datos pueden almacenarse en \textbf{forma} formateada o no formateada:

\begin{itemize}
	\item \textbf{Formateada}: la información se guarda como caracteres ASCII, legibles con la mayoría de los procesadores de texto.
	\item \textbf{No formateada}: un fichero es una serie de registros formados por ``bloques físicos''.
\end{itemize}

\subsection{Lectura y escritura de datos}

Internamente el ordenador representa los números y caracteres con cierta codificación. Para poder interpretar unos datos de entrada o mostrar unos datos de salida de forma legible se hacen conversiones entre la representación interna y la externa mediante especificaciones de formato. \\

Las entidades a leer o escribir se llaman listas de entrada/salida (lista I/O). En entrada se deben leer variables, en salida pueden escribirse expresiones. Si un array está en una lista I/O, se consideran todos los elementos del array en el orden de un almacenamiento del array. Una lista puede contener un DO implícito de variables.  \\

Existen 3 formas de indicar el formato de los datos a leer o escribir:

\begin{itemize}
	\item Sentencia {\tt FORMAT} con etiqueta.
	\begin{itemize}
		\item Sintaxis: {\tt e FORMAT (codform)} 
		\item Acción: {\tt codform} especifica los códigos de formato de lectura o escritura. 
		\item Normas: {\tt e} es un número de etiqueta. Es una sentencia no ejecutable.
	\end{itemize}
	\item Una expresión carácter que contiene el formato entre paréntesis.
	\item Un asterístco * que indica formato libre (lista directa de entrada-salida).
\end{itemize}

Cada fichero {\bf externo} (terminal, impresora, fichero en disco ó en cinta...) del qeu se lee o en el qeu se escribe lleva asociado un número de unidad no negativo, generalmente en el rango 1 a 99. Un número de unidad {\tt u} asociado a un fichero externo puede ser:

\begin{itemize}
	\item Una expresión entera con valor admisible (generalmente $1\leq u \leq 99$).
	\item Un asterisco: entrada/salida estándar por defecto (generalmente teclado y pantalla).
\end{itemize}

Toda la sentencia de lectura o escritura en un fichero externo debe referirse explícitamente a su número de unidad asociado. Hay dos excepciones:

\begin{itemize}
	\item Sentencia {\tt READ} sin número de unidad.
	\begin{itemize}
		\item Sintaxis: {\tt READ} sin número de unidad.
		\item Acción: lee datos del teclado (en modo interactivo). {\tt fmt} indica el formato.
	\end{itemize}
	\item Sentencia {\t PRINT}
	\begin{itemize}
		\item Sintaxis: {\tt PRINT fmt [,listavar]}
		\item Escribe los datos en la pantalla (en modo interactivo) con el formato {\tt fmt}.
	\end{itemize}
\end{itemize}

\section{Elaboración de programas}

Es importante cuidar la elaboración del programa fuente y procurar satisfacer varios objetivos, entre otros: que sea claro y legible tanto para el autor del programa como para otros potenciales usuarios, que sea fácil de detectar errores, que sea eficiente en tiempo, precisión o memoria, que permita introducir cambios con facilidad, etc.

\subsection{Estilo de programación}

Algunos detalles que favorecen el estilo de programación son:

\begin{itemize}
	\item Amplio uso de comentarios: incluir una breve descripción de algoritmos o procedimientos al principio de cada unidad de programa, en secciones de código diferencias, en límties de arrays, en sentencias que deberían cambiarse para ejecución con otros datos, etc.
	\item Descripción del significado de cada variable.
	\item Declaración organizada de variables (alfabética, por tipos, agrupada por similaridades, etc.).
	\item Líneas en blanco de separación entre secciones de código (blucles, bloques, {\tt IF},...) y entre subprogramas.
	\item Desplazamiento (``Identación'') de las sentencais de estructuras (blucles, bloques, {\tt IF, CASE,...}) unos espacios (6 espacios).

\end{itemize}
\subsection{Depuración de errores}

Los errores que pueden cometerse en la elaboración de un programa Fortran son de clase muy diversa: sintaxis, diseño de programa, programación, algorítmicos, instalación del software, errores de tamaño de memoria, etc. Una vez realizada una correcta instalción del software, los otros errores son imputables al usuario ó a limitaciones del software o hardware. La ley de MURPHY no falla cuando se aplica en programación. Algunos detalles que favorecen la detección y correción de errores son:

\begin{itemize}
	\item Una redaccion clara con suficientes comentarios.
	\item Evitar estructuras de control, formatos y expresiones complicados.
	\item Si un programa es muy largo, conviene partirlo en subprogramas. Es difícil corregir un subprograma de más de unasd 300 líneas ejecutables.
	\item En primeras versiones de un programa, conviene incluir sentencias de escritura (a pantalla ó fichero) después de secciones diferenciadas de código con objeto de aislar posibles errores o comprobar el buen funcionamiento de partes de código.
\end{itemize}


\subsection{Optimización de programas}

Algunos detalles que afectan a la eficiencia de un programa son:

\begin{itemize}
	\item Uso de la opción de compilación para optimizar la velocidad de ejecución.
	\item Potenciación {\tt a**b}:
	      \begin{itemize}
		      \item Si {\tt b }es entero, tenemos que hasta {\tt b}$>$5 la exponenciación se obtiene con {\it multiplicaciones}.
		      \item Si {\tt b }es real, se calcula como {\tt EXP(b*LOG(a))}.
	      \end{itemize}
	\item La raíz cuadrada es una operación rápida.
	\item Siempre que se pueda conviene ahorrar operaciones y simplificar fórmulas aunque las expresiones pueden ser numéricamente distintas.
	\item Si no hay peligro conviene reutilizar variables, vectores, y matrices. Si los elementos de un vector o matriz son conocidos, se pueden prescidir de ellos. El acceso a elementos de arrays consume tiempo.
\end{itemize}